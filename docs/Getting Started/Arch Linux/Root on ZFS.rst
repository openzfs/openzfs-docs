.. highlight:: sh

.. ifconfig:: zfs_root_test

 ::

  # For the CI/CD test run of this guide,
  # Enable verbose logging of bash shell and fail immediately when
  # a commmand fails.
  set -vxeuf
  distro=${1}

  cp /etc/resolv.conf ./"rootfs-${distro}"/etc/resolv.conf
  arch-chroot ./"rootfs-${distro}" sh <<-'ZFS_ROOT_GUIDE_TEST'

  set -vxeuf

  # install alpine setup scripts
  apk update
  apk add alpine-conf curl

.. In this document, there are three types of code-block markups:
   ``::`` are commands intended for both the vm test and the users
   ``.. ifconfig:: zfs_root_test`` are commands intended only for vm test
   ``.. code-block:: sh`` are commands intended only for users

Arch Linux Root on ZFS
=======================================

**ZFSBootMenu**

`ZFSBootMenu <https://zfsbootmenu.org>`__ is an alternative bootloader
free of such limitations and has support for boot environments. Do not
follow instructions on this page if you plan to use ZBM,
as the layouts are not compatible.  Refer
to their site for installation details.

**Customization**

Unless stated otherwise, it is not recommended to customize system
configuration before reboot.

**Only use well-tested pool features**

You should only use well-tested pool features.  Avoid using new features if data integrity is paramount.  See, for example, `this comment <https://github.com/openzfs/openzfs-docs/pull/464#issuecomment-1776918481>`__.

**UEFI support only**

Only UEFI is supported by this guide.

Preparation
---------------------------

#. Disable Secure Boot. ZFS modules can not be loaded if Secure Boot is enabled.
#. Because the kernel of latest Live CD might be incompatible with
   ZFS, we will use Alpine Linux Extended, which ships with ZFS by
   default.

   Download latest extended variant of `Alpine Linux
   live image
   <https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-extended-3.19.0-x86_64.iso>`__,
   verify `checksum <https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-extended-3.19.0-x86_64.iso.asc>`__
   and boot from it.

   .. code-block:: sh

       gpg --auto-key-retrieve --keyserver hkps://keyserver.ubuntu.com --verify alpine-extended-*.asc

       dd if=input-file of=output-file bs=1M

   .. ifconfig:: zfs_root_test

     # check whether the download page exists
      # alpine version must be in sync with ci/cd test chroot tarball

#. Login as root user.  There is no password.
#. Configure Internet

   .. code-block:: sh

     setup-interfaces -r
     # You must use "-r" option to start networking services properly
     # example:
     network interface: wlan0
     WiFi name:         <ssid>
     ip address:        dhcp
     <enter done to finish network config>
     manual netconfig:  n

#. If you are using wireless network and it is not shown, see `Alpine
   Linux wiki
   <https://wiki.alpinelinux.org/wiki/Wi-Fi#wpa_supplicant>`__ for
   further details.  ``wpa_supplicant`` can be installed with ``apk
   add wpa_supplicant`` without internet connection.

#. Configure SSH server

   .. code-block:: sh

     setup-sshd
     # example:
     ssh server:        openssh
     allow root:        "prohibit-password" or "yes"
     ssh key:           "none" or "<public key>"

#. Set root password or ``/root/.ssh/authorized_keys``.

#. Connect from another computer

   .. code-block:: sh

    ssh root@192.168.1.91

#. Configure NTP client for time synchronization

   .. code-block:: sh

     setup-ntp busybox

   .. ifconfig:: zfs_root_test

     # this step is unnecessary for chroot and returns 1 when executed

#. Set up apk-repo.  A list of available mirrors is shown.
   Press space bar to continue

   .. code-block:: sh

    setup-apkrepos

#. Throughout this guide, we use predictable disk names generated by
   udev

   .. code-block:: sh

     apk update
     apk add eudev
     setup-devd udev

   .. ifconfig:: zfs_root_test

      # for some reason, udev is extremely slow in chroot
      # it is not needed for chroot anyway. so, skip this step

#. Target disk

   List available disks with

   .. code-block:: sh

    find /dev/disk/by-id/

   If virtio is used as disk bus, power off the VM and set serial numbers for disk.
   For QEMU, use ``-drive format=raw,file=disk2.img,serial=AaBb``.
   For libvirt, edit domain XML.  See `this page
   <https://bugzilla.redhat.com/show_bug.cgi?id=1245013>`__ for examples.

   Declare disk array

   .. code-block:: sh

    DISK='/dev/disk/by-id/ata-FOO /dev/disk/by-id/nvme-BAR'

   For single disk installation, use

   .. code-block:: sh

    DISK='/dev/disk/by-id/disk1'

   .. ifconfig:: zfs_root_test

    # for github test run, use chroot and loop devices
    DISK="$(losetup -a| grep archlinux | cut -f1 -d: | xargs -t -I '{}' printf '{} ')"

#. Set a mount point
   ::

      MNT=$(mktemp -d)

#. Set partition size:

   Set swap size in GB, set to 1 if you don't want swap to
   take up too much space

   .. code-block:: sh

    SWAPSIZE=4

   .. ifconfig:: zfs_root_test

    # For the test run, use 1GB swap space to avoid hitting CI/CD
    # quota
    SWAPSIZE=1

   Set how much space should be left at the end of the disk, minimum 1GB

   ::

    RESERVE=1

#. Install ZFS support from live media::

    apk add zfs

#. Install partition tool
   ::

      apk add parted e2fsprogs cryptsetup util-linux

System Installation
---------------------------

#. Partition the disks.

   Note: you must clear all existing partition tables and data structures from target disks.

   For flash-based storage, this can be done by the blkdiscard command below:
   ::

     partition_disk () {
      local disk="${1}"
      blkdiscard -f "${disk}" || true

      parted --script --align=optimal  "${disk}" -- \
      mklabel gpt \
      mkpart EFI 1MiB 4GiB \
      mkpart rpool 4GiB -$((SWAPSIZE + RESERVE))GiB \
      mkpart swap  -$((SWAPSIZE + RESERVE))GiB -"${RESERVE}"GiB \
      set 1 esp on \

      partprobe "${disk}"
     }

     for i in ${DISK}; do
        partition_disk "${i}"
     done

   .. ifconfig:: zfs_root_test

      ::

       # When working with GitHub chroot runners, we are using loop
       # devices as installation target.  However, the alias support for
       # loop device was just introduced in March 2023. See
       # https://github.com/systemd/systemd/pull/26693
       # For now, we will create the aliases maunally as a workaround
       looppart="1 2 3 4 5"
       for i in ${DISK}; do
         for j in ${looppart}; do
           if test -e "${i}p${j}"; then
                    ln -s "${i}p${j}" "${i}-part${j}"
                  fi
         done
       done


#. Setup temporary encrypted swap for this installation only.  This is
   useful if the available memory is small::

     for i in ${DISK}; do
        cryptsetup open --type plain --key-file /dev/random "${i}"-part3 "${i##*/}"-part3
        mkswap /dev/mapper/"${i##*/}"-part3
        swapon /dev/mapper/"${i##*/}"-part3
     done


#. Load ZFS kernel module

   .. code-block:: sh

       modprobe zfs

#. Create root pool

   - Unencrypted::

       # shellcheck disable=SC2046
       zpool create \
           -o ashift=12 \
           -o autotrim=on \
           -R "${MNT}" \
           -O acltype=posixacl \
           -O canmount=off \
           -O dnodesize=auto \
           -O normalization=formD \
           -O relatime=on \
           -O xattr=sa \
           -O mountpoint=none \
           rpool \
           mirror \
          $(for i in ${DISK}; do
             printf '%s ' "${i}-part2";
            done)

#. Create root system container:

     ::

      zfs create -o canmount=noauto -o mountpoint=legacy rpool/root

   Create system datasets,
   manage mountpoints with ``mountpoint=legacy``
   ::

      zfs create -o mountpoint=legacy rpool/home
      mount -o X-mount.mkdir -t zfs rpool/root "${MNT}"
      mount -o X-mount.mkdir -t zfs rpool/home "${MNT}"/home

#. Format and mount ESP.  Only one of them is used as /boot, you need to set up mirroring afterwards
   ::

     for i in ${DISK}; do
      mkfs.vfat -n EFI "${i}"-part1
     done

     for i in ${DISK}; do
      mount -t vfat -o fmask=0077,dmask=0077,iocharset=iso8859-1,X-mount.mkdir "${i}"-part1 "${MNT}"/boot
      break
     done

System Configuration 
---------------------------

#. Download and extract minimal Arch Linux root filesystem::

     apk add curl

     curl --fail-early --fail -L \
     https://america.archive.pkgbuild.com/iso/2024.01.01/archlinux-bootstrap-x86_64.tar.gz \
     -o rootfs.tar.gz
     curl --fail-early --fail -L \
     https://america.archive.pkgbuild.com/iso/2024.01.01/archlinux-bootstrap-x86_64.tar.gz.sig \
     -o rootfs.tar.gz.sig

     apk add gnupg
     gpg --auto-key-retrieve --keyserver hkps://keyserver.ubuntu.com --verify rootfs.tar.gz.sig

     ln -s "${MNT}" "${MNT}"/root.x86_64
     tar x  -C "${MNT}" -af rootfs.tar.gz root.x86_64

#. Enable community repo

   .. code-block:: sh

    sed -i '/edge/d' /etc/apk/repositories
    sed -i -E 's/#(.*)community/\1community/' /etc/apk/repositories

#. Generate fstab::

    apk add arch-install-scripts
    genfstab -t PARTUUID "${MNT}" \
    | grep -v swap \
    | sed "s|vfat.*rw|vfat rw,x-systemd.idle-timeout=1min,x-systemd.automount,noauto,nofail|" \
    > "${MNT}"/etc/fstab

#. Chroot

   .. code-block:: sh

    cp /etc/resolv.conf "${MNT}"/etc/resolv.conf
    for i in /dev /proc /sys; do mkdir -p "${MNT}"/"${i}"; mount --rbind "${i}" "${MNT}"/"${i}"; done
    chroot "${MNT}" /usr/bin/env DISK="${DISK}" bash

   .. ifconfig:: zfs_root_test

    ::

     cp /etc/resolv.conf "${MNT}"/etc/resolv.conf
     for i in /dev /proc /sys; do mkdir -p "${MNT}"/"${i}"; mount --rbind "${i}" "${MNT}"/"${i}"; done
     chroot "${MNT}" /usr/bin/env DISK="${DISK}" bash <<-'ZFS_ROOT_NESTED_CHROOT'

     set -vxeuf

#. Add archzfs repo to pacman config

   ::

       pacman-key --init
       pacman-key --refresh-keys
       pacman-key --populate

       curl --fail-early --fail -L https://archzfs.com/archzfs.gpg \
       |  pacman-key -a - --gpgdir /etc/pacman.d/gnupg

       pacman-key \
       --lsign-key \
       --gpgdir /etc/pacman.d/gnupg \
       DDF7DB817396A49B2A2723F7403BD972F75D9D76

       tee -a /etc/pacman.d/mirrorlist-archzfs <<- 'EOF'
       ## See https://github.com/archzfs/archzfs/wiki
       ## France
       #,Server = https://archzfs.com/$repo/$arch

       ## Germany
       #,Server = https://mirror.sum7.eu/archlinux/archzfs/$repo/$arch
       #,Server = https://mirror.biocrafting.net/archlinux/archzfs/$repo/$arch

       ## India
       #,Server = https://mirror.in.themindsmaze.com/archzfs/$repo/$arch

       ## United States
       #,Server = https://zxcvfdsa.com/archzfs/$repo/$arch
       EOF

       tee -a /etc/pacman.conf <<- 'EOF'

       #[archzfs-testing]
       #Include = /etc/pacman.d/mirrorlist-archzfs

       #,[archzfs]
       #,Include = /etc/pacman.d/mirrorlist-archzfs
       EOF

       # this #, prefix is a workaround for ci/cd tests
       # remove them
       sed -i 's|#,||' /etc/pacman.d/mirrorlist-archzfs
       sed -i 's|#,||' /etc/pacman.conf
       sed -i 's|^#||' /etc/pacman.d/mirrorlist

#. Install base packages::

     pacman -Sy
     pacman -S --noconfirm mg mandoc efibootmgr mkinitcpio

     kernel_compatible_with_zfs="$(pacman -Si zfs-linux \
     | grep 'Depends On' \
     | sed "s|.*linux=||" \
     | awk '{ print $1 }')"
     pacman -U --noconfirm https://america.archive.pkgbuild.com/packages/l/linux/linux-"${kernel_compatible_with_zfs}"-x86_64.pkg.tar.zst

#. Install zfs packages::

     pacman -S --noconfirm zfs-linux zfs-utils

#. Configure mkinitcpio::

     sed -i 's|filesystems|zfs filesystems|' /etc/mkinitcpio.conf
     mkinitcpio -P

#. For physical machine, install firmware

   .. code-block:: sh

     pacman -S linux-firmware intel-ucode amd-ucode

#. Enable internet time synchronisation::

     systemctl enable systemd-timesyncd

#. Generate host id::

    zgenhostid -f -o /etc/hostid

#. Generate locales::

    echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
    locale-gen

#. Set locale, keymap, timezone, hostname

   ::

    rm -f /etc/localtime
    systemd-firstboot \
    --force \
    --locale=en_US.UTF-8 \
    --timezone=Etc/UTC \
    --hostname=testhost \
    --keymap=us

#. Set root passwd
   ::

    printf 'root:yourpassword' | chpasswd

Bootloader
---------------------------

#. Install rEFInd boot loader::

     # from http://www.rodsbooks.com/refind/getting.html
     # use Binary Zip File option
     pacman -S --noconfirm unzip
     curl -L http://sourceforge.net/projects/refind/files/0.14.0.2/refind-bin-0.14.0.2.zip/download --output refind.zip

     unzip refind.zip
     mkdir -p /boot/EFI/BOOT
     find ./refind-bin-0.14.0.2/ -name 'refind_x64.efi' -print0 \
     | xargs -0I{} mv {} /boot/EFI/BOOT/BOOTX64.EFI
     rm -rf refind.zip refind-bin-0.14.0.2

#. Add boot entry::

     tee -a /boot/refind-linux.conf <<EOF
     "Arch Linux" "root=ZFS=rpool/root rw zfs_import_dir=/dev/"
     EOF

#. Exit chroot

   .. code-block:: sh

     exit

   .. ifconfig:: zfs_root_test

     # nested chroot ends here
     ZFS_ROOT_NESTED_CHROOT


#. Unmount filesystems and create initial system snapshot
   ::

    umount -Rl "${MNT}"
    zfs snapshot -r rpool@initial-installation

#. Export all pools

   .. code-block:: sh

    zpool export -a

   .. ifconfig:: zfs_root_test

    # we are now inside a chroot, where the export will fail
    # export pools when we are outside chroot

#. Reboot

   .. code-block:: sh

     reboot

   .. ifconfig:: zfs_root_test

     # chroot ends here
     ZFS_ROOT_GUIDE_TEST

#. Mount other EFI system partitions then set up a service for syncing
   their contents.
