

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>zfs.4 &mdash; OpenZFS  documentation</title>
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/mandoc.css" type="text/css" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="canonical" href="https://openzfs.github.io/openzfs-docs/man/v2.1/4/zfs.4.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../../../_static/js/redirect.js?v=2a1712f3"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="File Formats and Conventions (5)" href="../5/index.html" />
    <link rel="prev" title="spl.4" href="spl.4.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #29667e" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo_main.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../Getting%20Started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Project%20and%20Community/index.html">Project and Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Developer%20Resources/index.html">Developer Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Performance%20and%20Tuning/index.html">Performance and Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Basic%20Concepts/index.html">Basic Concepts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Man Pages</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../master/index.html">master</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v2.4/index.html">v2.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v2.3/index.html">v2.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v2.2/index.html">v2.2</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">v2.1</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../1/index.html">User Commands (1)</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Devices and Special Files (4)</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="spl.4.html">spl.4</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">zfs.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../5/index.html">File Formats and Conventions (5)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../7/index.html">Miscellaneous (7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../8/index.html">System Administration Commands (8)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../v2.0/index.html">v2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v0.8/index.html">v0.8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v0.7/index.html">v0.7</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v0.6/index.html">v0.6</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../msg/index.html">ZFS Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../License.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #29667e" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OpenZFS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Man Pages</a></li>
          <li class="breadcrumb-item"><a href="../index.html">v2.1</a></li>
          <li class="breadcrumb-item"><a href="index.html">Devices and Special Files (4)</a></li>
      <li class="breadcrumb-item active">zfs.4</li>
      <li class="wy-breadcrumbs-aside">
              <!-- User defined GitHub URL -->
              <a href="https://github.com/openzfs/zfs/blob/zfs-2.1.16/man/man4/zfs.4" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="zfs-4">
<h1>zfs.4<a class="headerlink" href="#zfs-4" title="Link to this heading">ÔÉÅ</a></h1>
<div class="man_container"><table class="head">
  <tr>
    <td class="head-ltitle">ZFS(4)</td>
    <td class="head-vol">Device Drivers Manual</td>
    <td class="head-rtitle">ZFS(4)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">zfs</code> &#x2014; <span class="Nd">tuning of
    the ZFS kernel module</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The ZFS module supports these parameters:</p>
<dl class="Bl-tag">
  <dt id="dbuf_cache_max_bytes"><a class="permalink" href="#dbuf_cache_max_bytes"><b class="Sy">dbuf_cache_max_bytes</b></a>=<b class="Sy">ULONG_MAX</b>B
    (ulong)</dt>
  <dd>Maximum size in bytes of the dbuf cache. The target size is determined by
      the MIN versus
      <span class="No">1/2^</span><b class="Sy">dbuf_cache_shift</b> (1/32nd) of
      the target ARC size. The behavior of the dbuf cache and its associated
      settings can be observed via the
      <span class="Pa">/proc/spl/kstat/zfs/dbufstats</span> kstat.</dd>
  <dt id="dbuf_metadata_cache_max_bytes"><a class="permalink" href="#dbuf_metadata_cache_max_bytes"><b class="Sy">dbuf_metadata_cache_max_bytes</b></a>=<b class="Sy">ULONG_MAX</b>B
    (ulong)</dt>
  <dd>Maximum size in bytes of the metadata dbuf cache. The target size is
      determined by the MIN versus
      <span class="No">1/2^</span><b class="Sy">dbuf_metadata_cache_shift</b>
      (1/64th) of the target ARC size. The behavior of the metadata dbuf cache
      and its associated settings can be observed via the
      <span class="Pa">/proc/spl/kstat/zfs/dbufstats</span> kstat.</dd>
  <dt id="dbuf_cache_hiwater_pct"><a class="permalink" href="#dbuf_cache_hiwater_pct"><b class="Sy">dbuf_cache_hiwater_pct</b></a>=<b class="Sy">10</b>%
    (uint)</dt>
  <dd>The percentage over <b class="Sy">dbuf_cache_max_bytes</b> when dbufs must
      be evicted directly.</dd>
  <dt id="dbuf_cache_lowater_pct"><a class="permalink" href="#dbuf_cache_lowater_pct"><b class="Sy">dbuf_cache_lowater_pct</b></a>=<b class="Sy">10</b>%
    (uint)</dt>
  <dd>The percentage below <b class="Sy">dbuf_cache_max_bytes</b> when the evict
      thread stops evicting dbufs.</dd>
  <dt id="dbuf_cache_shift"><a class="permalink" href="#dbuf_cache_shift"><b class="Sy">dbuf_cache_shift</b></a>=<b class="Sy">5</b>
    (int)</dt>
  <dd>Set the size of the dbuf cache (<b class="Sy">dbuf_cache_max_bytes</b>) to
      a log2 fraction of the target ARC size.</dd>
  <dt id="dbuf_metadata_cache_shift"><a class="permalink" href="#dbuf_metadata_cache_shift"><b class="Sy">dbuf_metadata_cache_shift</b></a>=<a class="permalink" href="#6"><b class="Sy" id="6">6</b></a>
    (int)</dt>
  <dd>Set the size of the dbuf metadata cache
      (<b class="Sy">dbuf_metadata_cache_max_bytes</b>) to a log2 fraction of
      the target ARC size.</dd>
  <dt id="dmu_object_alloc_chunk_shift"><a class="permalink" href="#dmu_object_alloc_chunk_shift"><b class="Sy">dmu_object_alloc_chunk_shift</b></a>=<b class="Sy">7</b>
    (128) (int)</dt>
  <dd>dnode slots allocated in a single operation as a power of 2. The default
      value minimizes lock contention for the bulk operation performed.</dd>
  <dt id="dmu_prefetch_max"><a class="permalink" href="#dmu_prefetch_max"><b class="Sy">dmu_prefetch_max</b></a>=<b class="Sy">134217728</b>B
    (128MB) (int)</dt>
  <dd>Limit the amount we can prefetch with one call to this amount in bytes.
      This helps to limit the amount of memory that can be used by
    prefetching.</dd>
  <dt id="ignore_hole_birth"><a class="permalink" href="#ignore_hole_birth"><b class="Sy">ignore_hole_birth</b></a>
    (int)</dt>
  <dd>Alias for <b class="Sy">send_holes_without_birth_time</b>.</dd>
  <dt id="l2arc_feed_again"><a class="permalink" href="#l2arc_feed_again"><b class="Sy">l2arc_feed_again</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Turbo L2ARC warm-up. When the L2ARC is cold the fill interval will be set
      as fast as possible.</dd>
  <dt id="l2arc_feed_min_ms"><a class="permalink" href="#l2arc_feed_min_ms"><b class="Sy">l2arc_feed_min_ms</b></a>=<b class="Sy">200</b>
    (ulong)</dt>
  <dd>Min feed interval in milliseconds. Requires
      <b class="Sy">l2arc_feed_again</b>=<var class="Ar">1</var> and only
      applicable in related situations.</dd>
  <dt id="l2arc_feed_secs"><a class="permalink" href="#l2arc_feed_secs"><b class="Sy">l2arc_feed_secs</b></a>=<b class="Sy">1</b>
    (ulong)</dt>
  <dd>Seconds between L2ARC writing.</dd>
  <dt id="l2arc_headroom"><a class="permalink" href="#l2arc_headroom"><b class="Sy">l2arc_headroom</b></a>=<b class="Sy">2</b>
    (ulong)</dt>
  <dd>How far through the ARC lists to search for L2ARC cacheable content,
      expressed as a multiplier of <b class="Sy">l2arc_write_max</b>. ARC
      persistence across reboots can be achieved with persistent L2ARC by
      setting this parameter to <b class="Sy">0</b>, allowing the full length of
      ARC lists to be searched for cacheable content.</dd>
  <dt id="l2arc_headroom_boost"><a class="permalink" href="#l2arc_headroom_boost"><b class="Sy">l2arc_headroom_boost</b></a>=<b class="Sy">200</b>%
    (ulong)</dt>
  <dd>Scales <b class="Sy">l2arc_headroom</b> by this percentage when L2ARC
      contents are being successfully compressed before writing. A value of
      <b class="Sy">100</b> disables this feature.</dd>
  <dt id="l2arc_exclude_special"><a class="permalink" href="#l2arc_exclude_special"><b class="Sy">l2arc_exclude_special</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Controls whether buffers present on special vdevs are eligibile for
      caching into L2ARC. If set to 1, exclude dbufs on special vdevs from being
      cached to L2ARC.</dd>
  <dt id="l2arc_mfuonly"><a class="permalink" href="#l2arc_mfuonly"><b class="Sy">l2arc_mfuonly</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Controls whether only MFU metadata and data are cached from ARC into
      L2ARC. This may be desired to avoid wasting space on L2ARC when
      reading/writing large amounts of data that are not expected to be accessed
      more than once.
    <p class="Pp">The default is off, meaning both MRU and MFU data and metadata
        are cached. When turning off this feature, some MRU buffers will still
        be present in ARC and eventually cached on L2ARC.
        <span class="No">If</span>
        <b class="Sy">l2arc_noprefetch</b>=<b class="Sy">0</b>, some prefetched
        buffers will be cached to L2ARC, and those might later transition to
        MRU, in which case the <b class="Sy">l2arc_mru_asize</b>
        <span class="No">arcstat will not be</span> <b class="Sy">0</b>.</p>
    <p class="Pp">Regardless of <b class="Sy">l2arc_noprefetch</b>, some MFU
        buffers might be evicted from ARC, accessed later on as prefetches and
        transition to MRU as prefetches. If accessed again they are counted as
        MRU and the <b class="Sy">l2arc_mru_asize</b> <span class="No">arcstat
        will not be</span> <b class="Sy">0</b>.</p>
    <p class="Pp" id="l2arc_mfu_asize">The ARC status of L2ARC buffers when they
        were first cached in L2ARC can be seen in the
        <b class="Sy">l2arc_mru_asize</b>,
        <a class="permalink" href="#l2arc_mfu_asize"><b class="Sy">l2arc_mfu_asize</b></a>,
        <span class="No">and</span>
        <a class="permalink" href="#l2arc_prefetch_asize"><b class="Sy" id="l2arc_prefetch_asize">l2arc_prefetch_asize</b></a>
        arcstats when importing the pool or onlining a cache device if
        persistent L2ARC is enabled.</p>
    <p class="Pp" id="evict_l2_eligible_mru">The
        <a class="permalink" href="#evict_l2_eligible_mru"><b class="Sy">evict_l2_eligible_mru</b></a>
        arcstat does not take into account if this option is enabled as the
        information provided by the
        <a class="permalink" href="#evict_l2_eligible_m_rf_u"><b class="Sy" id="evict_l2_eligible_m_rf_u">evict_l2_eligible_m[rf]u</b></a>
        arcstats can be used to decide if toggling this option is appropriate
        for the current workload.</p>
  </dd>
  <dt id="l2arc_meta_percent"><a class="permalink" href="#l2arc_meta_percent"><b class="Sy">l2arc_meta_percent</b></a>=<a class="permalink" href="#33"><b class="Sy" id="33">33</b></a>%
    (int)</dt>
  <dd>Percent of ARC size allowed for L2ARC-only headers. Since L2ARC buffers
      are not evicted on memory pressure, too many headers on a system with an
      irrationally large L2ARC can render it slow or unusable. This parameter
      limits L2ARC writes and rebuilds to achieve the target.</dd>
  <dt id="l2arc_trim_ahead"><a class="permalink" href="#l2arc_trim_ahead"><b class="Sy">l2arc_trim_ahead</b></a>=<b class="Sy">0</b>%
    (ulong)</dt>
  <dd>Trims ahead of the current write size (<b class="Sy">l2arc_write_max</b>)
      on L2ARC devices by this percentage of write size if we have filled the
      device. If set to <b class="Sy">100</b> we TRIM twice the space required
      to accommodate upcoming writes. A minimum of
      <a class="permalink" href="#64MB"><b class="Sy" id="64MB">64MB</b></a>
      will be trimmed. It also enables TRIM of the whole L2ARC device upon
      creation or addition to an existing pool or if the header of the device is
      invalid upon importing a pool or onlining a cache device. A value of
      <b class="Sy">0</b> disables TRIM on L2ARC altogether and is the default
      as it can put significant stress on the underlying storage devices. This
      will vary depending of how well the specific device handles these
      commands.</dd>
  <dt id="l2arc_noprefetch"><a class="permalink" href="#l2arc_noprefetch"><b class="Sy">l2arc_noprefetch</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Do not write buffers to L2ARC if they were prefetched but not used by
      applications. In case there are prefetched buffers in L2ARC and this
      option is later set, we do not read the prefetched buffers from L2ARC.
      Unsetting this option is useful for caching sequential reads from the
      disks to L2ARC and serve those reads from L2ARC later on. This may be
      beneficial in case the L2ARC device is significantly faster in sequential
      reads than the disks of the pool.
    <p class="Pp">Use <b class="Sy">1</b> to disable and <b class="Sy">0</b> to
        enable caching/reading prefetches to/from L2ARC.</p>
  </dd>
  <dt id="l2arc_norw"><a class="permalink" href="#l2arc_norw"><b class="Sy">l2arc_norw</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>No reads during writes.</dd>
  <dt id="l2arc_write_boost"><a class="permalink" href="#l2arc_write_boost"><b class="Sy">l2arc_write_boost</b></a>=<b class="Sy">8388608</b>B
    (8MB) (ulong)</dt>
  <dd>Cold L2ARC devices will have <b class="Sy">l2arc_write_max</b> increased
      by this amount while they remain cold.</dd>
  <dt id="l2arc_write_max"><a class="permalink" href="#l2arc_write_max"><b class="Sy">l2arc_write_max</b></a>=<b class="Sy">8388608</b>B
    (8MB) (ulong)</dt>
  <dd>Max write bytes per interval.</dd>
  <dt id="l2arc_rebuild_enabled"><a class="permalink" href="#l2arc_rebuild_enabled"><b class="Sy">l2arc_rebuild_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Rebuild the L2ARC when importing a pool (persistent L2ARC). This can be
      disabled if there are problems importing a pool or attaching an L2ARC
      device (e.g. the L2ARC device is slow in reading stored log metadata, or
      the metadata has become somehow fragmented/unusable).</dd>
  <dt id="l2arc_rebuild_blocks_min_l2size"><a class="permalink" href="#l2arc_rebuild_blocks_min_l2size"><b class="Sy">l2arc_rebuild_blocks_min_l2size</b></a>=<b class="Sy">1073741824</b>B
    (1GB) (ulong)</dt>
  <dd>Mininum size of an L2ARC device required in order to write log blocks in
      it. The log blocks are used upon importing the pool to rebuild the
      persistent L2ARC.
    <p class="Pp" id="l2arc_evict">For L2ARC devices less than 1GB, the amount
        of data
        <a class="permalink" href="#l2arc_evict"><code class="Fn">l2arc_evict</code></a>()
        evicts is significant compared to the amount of restored L2ARC data. In
        this case, do not write log blocks in L2ARC in order not to waste
      space.</p>
  </dd>
  <dt id="metaslab_aliquot"><a class="permalink" href="#metaslab_aliquot"><b class="Sy">metaslab_aliquot</b></a>=<b class="Sy">1048576</b>B
    (1MB) (ulong)</dt>
  <dd>Metaslab granularity, in bytes. This is roughly similar to what would be
      referred to as the &quot;stripe size&quot; in traditional RAID arrays. In
      normal operation, ZFS will try to write this amount of data to each disk
      before moving on to the next top-level vdev.</dd>
  <dt id="metaslab_bias_enabled"><a class="permalink" href="#metaslab_bias_enabled"><b class="Sy">metaslab_bias_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable metaslab group biasing based on their vdevs' over- or
      under-utilization relative to the pool.</dd>
  <dt id="metaslab_force_ganging"><a class="permalink" href="#metaslab_force_ganging"><b class="Sy">metaslab_force_ganging</b></a>=<a class="permalink" href="#16777217"><b class="Sy" id="16777217">16777217</b></a>BB
    (16MB + 1B) (ulong)</dt>
  <dd>Make some blocks above a certain size be gang blocks. This option is used
      by the test suite to facilitate testing.</dd>
  <dt id="zfs_default_bs"><a class="permalink" href="#zfs_default_bs"><b class="Sy">zfs_default_bs</b></a>=<b class="Sy">9</b>
    (512 B) (int)</dt>
  <dd>Default dnode block size as a power of 2.</dd>
  <dt id="zfs_default_ibs"><a class="permalink" href="#zfs_default_ibs"><b class="Sy">zfs_default_ibs</b></a>=<a class="permalink" href="#17"><b class="Sy" id="17">17</b></a>
    (128 KiB) (int)</dt>
  <dd>Default dnode indirect block size as a power of 2.</dd>
  <dt id="zfs_history_output_max"><a class="permalink" href="#zfs_history_output_max"><b class="Sy">zfs_history_output_max</b></a>=<b class="Sy">1048576</b>BB
    (1MB) (int)</dt>
  <dd>When attempting to log an output nvlist of an ioctl in the on-disk
      history, the output will not be stored if it is larger than this size (in
      bytes). This must be less than
      <a class="permalink" href="#DMU_MAX_ACCESS"><b class="Sy" id="DMU_MAX_ACCESS">DMU_MAX_ACCESS</b></a>
      (64MB). This applies primarily to
      <a class="permalink" href="#zfs_ioc_channel_program"><code class="Fn" id="zfs_ioc_channel_program">zfs_ioc_channel_program</code></a>()
      (cf. <a href="../8/zfs-program.8.html" class="Xr">zfs-program(8)</a>).</dd>
  <dt id="zfs_keep_log_spacemaps_at_export"><a class="permalink" href="#zfs_keep_log_spacemaps_at_export"><b class="Sy">zfs_keep_log_spacemaps_at_export</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Prevent log spacemaps from being destroyed during pool exports and
      destroys.</dd>
  <dt id="zfs_metaslab_segment_weight_enabled"><a class="permalink" href="#zfs_metaslab_segment_weight_enabled"><b class="Sy">zfs_metaslab_segment_weight_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable/disable segment-based metaslab selection.</dd>
  <dt id="zfs_metaslab_switch_threshold"><a class="permalink" href="#zfs_metaslab_switch_threshold"><b class="Sy">zfs_metaslab_switch_threshold</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>When using segment-based metaslab selection, continue allocating from the
      active metaslab until this option's worth of buckets have been
    exhausted.</dd>
  <dt id="metaslab_debug_load"><a class="permalink" href="#metaslab_debug_load"><b class="Sy">metaslab_debug_load</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Load all metaslabs during pool import.</dd>
  <dt id="metaslab_debug_unload"><a class="permalink" href="#metaslab_debug_unload"><b class="Sy">metaslab_debug_unload</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Prevent metaslabs from being unloaded.</dd>
  <dt id="metaslab_fragmentation_factor_enabled"><a class="permalink" href="#metaslab_fragmentation_factor_enabled"><b class="Sy">metaslab_fragmentation_factor_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable use of the fragmentation metric in computing metaslab weights.</dd>
  <dt id="metaslab_df_max_search"><a class="permalink" href="#metaslab_df_max_search"><b class="Sy">metaslab_df_max_search</b></a>=<b class="Sy">16777216</b>B
    (16MB) (int)</dt>
  <dd>Maximum distance to search forward from the last offset. Without this
      limit, fragmented pools can see
      <a class="permalink" href="#_100_000"><i class="Em" id="_100_000">&gt;100`000</i></a>
      iterations and
      <a class="permalink" href="#metaslab_block_picker"><code class="Fn" id="metaslab_block_picker">metaslab_block_picker</code></a>()
      becomes the performance limiting factor on high-performance storage.
    <p class="Pp" id="16*1024">With the default setting of
        <b class="Sy">16MB</b>, we typically see less than <i class="Em">500</i>
        iterations, even with very fragmented
        <b class="Sy">ashift</b>=<b class="Sy">9</b> pools. The maximum number
        of iterations possible is <b class="Sy">metaslab_df_max_search /
        2^(ashift+1)</b>. With the default setting of <b class="Sy">16MB</b>
        this is
        <a class="permalink" href="#16*1024"><i class="Em">16*1024</i></a> (with
        <b class="Sy">ashift</b>=<b class="Sy">9</b>) or
        <a class="permalink" href="#2*1024"><i class="Em" id="2*1024">2*1024</i></a>
        (with
        <b class="Sy">ashift</b>=<a class="permalink" href="#12"><b class="Sy" id="12">12</b></a>).</p>
  </dd>
  <dt id="metaslab_df_use_largest_segment"><a class="permalink" href="#metaslab_df_use_largest_segment"><b class="Sy">metaslab_df_use_largest_segment</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>If not searching forward (due to <b class="Sy">metaslab_df_max_search</b>,
      <a class="permalink" href="#metaslab_df_free_pct"><b class="Sy" id="metaslab_df_free_pct">metaslab_df_free_pct</b></a>,
      <span class="No">or</span>
      <a class="permalink" href="#metaslab_df_alloc_threshold"><b class="Sy" id="metaslab_df_alloc_threshold">metaslab_df_alloc_threshold</b></a>),
      this tunable controls which segment is used. If set, we will use the
      largest free segment. If unset, we will use a segment of at least the
      requested size.</dd>
  <dt id="zfs_metaslab_max_size_cache_sec"><a class="permalink" href="#zfs_metaslab_max_size_cache_sec"><b class="Sy">zfs_metaslab_max_size_cache_sec</b></a>=<a class="permalink" href="#3600"><b class="Sy" id="3600">3600</b></a>s
    (1h) (ulong)</dt>
  <dd>When we unload a metaslab, we cache the size of the largest free chunk. We
      use that cached size to determine whether or not to load a metaslab for a
      given allocation. As more frees accumulate in that metaslab while it's
      unloaded, the cached max size becomes less and less accurate. After a
      number of seconds controlled by this tunable, we stop considering the
      cached max size and start considering only the histogram instead.</dd>
  <dt id="zfs_metaslab_mem_limit"><a class="permalink" href="#zfs_metaslab_mem_limit"><b class="Sy">zfs_metaslab_mem_limit</b></a>=<b class="Sy">25</b>%
    (int)</dt>
  <dd>When we are loading a new metaslab, we check the amount of memory being
      used to store metaslab range trees. If it is over a threshold, we attempt
      to unload the least recently used metaslab to prevent the system from
      clogging all of its memory with range trees. This tunable sets the
      percentage of total system memory that is the threshold.</dd>
  <dt id="zfs_metaslab_try_hard_before_gang"><a class="permalink" href="#zfs_metaslab_try_hard_before_gang"><b class="Sy">zfs_metaslab_try_hard_before_gang</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>
    <ul class="Bl-item Bl-compact">
      <li>If unset, we will first try normal allocation.</li>
      <li>If that fails then we will do a gang allocation.</li>
      <li>If that fails then we will do a &quot;try hard&quot; gang
        allocation.</li>
      <li>If that fails then we will have a multi-layer gang block.</li>
    </ul>
    <p class="Pp"></p>
    <ul class="Bl-item Bl-compact">
      <li>If set, we will first try normal allocation.</li>
      <li>If that fails then we will do a &quot;try hard&quot; allocation.</li>
      <li>If that fails we will do a gang allocation.</li>
      <li>If that fails we will do a &quot;try hard&quot; gang allocation.</li>
      <li>If that fails then we will have a multi-layer gang block.</li>
    </ul>
  </dd>
  <dt id="zfs_metaslab_find_max_tries"><a class="permalink" href="#zfs_metaslab_find_max_tries"><b class="Sy">zfs_metaslab_find_max_tries</b></a>=<b class="Sy">100</b>
    (int)</dt>
  <dd>When not trying hard, we only consider this number of the best metaslabs.
      This improves performance, especially when there are many metaslabs per
      vdev and the allocation can't actually be satisfied (so we would otherwise
      iterate all metaslabs).</dd>
  <dt id="zfs_vdev_default_ms_count"><a class="permalink" href="#zfs_vdev_default_ms_count"><b class="Sy">zfs_vdev_default_ms_count</b></a>=<b class="Sy">200</b>
    (int)</dt>
  <dd>When a vdev is added, target this number of metaslabs per top-level
    vdev.</dd>
  <dt id="zfs_vdev_default_ms_shift"><a class="permalink" href="#zfs_vdev_default_ms_shift"><b class="Sy">zfs_vdev_default_ms_shift</b></a>=<a class="permalink" href="#29"><b class="Sy" id="29">29</b></a>
    (512MB) (int)</dt>
  <dd>Default limit for metaslab size.</dd>
  <dt id="zfs_vdev_max_auto_ashift"><a class="permalink" href="#zfs_vdev_max_auto_ashift"><b class="Sy">zfs_vdev_max_auto_ashift</b></a>=<a class="permalink" href="#14"><b class="Sy" id="14">14</b></a>
    (ulong)</dt>
  <dd>Maximum ashift used when optimizing for logical -&gt; physical sector size
      on new top-level vdevs. May be increased up to
      <a class="permalink" href="#ASHIFT_MAX"><b class="Sy" id="ASHIFT_MAX">ASHIFT_MAX</b></a>
      (16), but this may negatively impact pool space efficiency.</dd>
  <dt id="zfs_vdev_min_auto_ashift"><a class="permalink" href="#zfs_vdev_min_auto_ashift"><b class="Sy">zfs_vdev_min_auto_ashift</b></a>=<a class="permalink" href="#ASHIFT_MIN"><b class="Sy" id="ASHIFT_MIN">ASHIFT_MIN</b></a>
    (9) (ulong)</dt>
  <dd>Minimum ashift used when creating new top-level vdevs.</dd>
  <dt id="zfs_vdev_min_ms_count"><a class="permalink" href="#zfs_vdev_min_ms_count"><b class="Sy">zfs_vdev_min_ms_count</b></a>=<b class="Sy">16</b>
    (int)</dt>
  <dd>Minimum number of metaslabs to create in a top-level vdev.</dd>
  <dt id="vdev_validate_skip"><a class="permalink" href="#vdev_validate_skip"><b class="Sy">vdev_validate_skip</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Skip label validation steps during pool import. Changing is not
      recommended unless you know what you're doing and are recovering a damaged
      label.</dd>
  <dt id="zfs_vdev_ms_count_limit"><a class="permalink" href="#zfs_vdev_ms_count_limit"><b class="Sy">zfs_vdev_ms_count_limit</b></a>=<b class="Sy">131072</b>
    (128k) (int)</dt>
  <dd>Practical upper limit of total metaslabs per top-level vdev.</dd>
  <dt id="metaslab_preload_enabled"><a class="permalink" href="#metaslab_preload_enabled"><b class="Sy">metaslab_preload_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable metaslab group preloading.</dd>
  <dt id="metaslab_lba_weighting_enabled"><a class="permalink" href="#metaslab_lba_weighting_enabled"><b class="Sy">metaslab_lba_weighting_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Give more weight to metaslabs with lower LBAs, assuming they have greater
      bandwidth, as is typically the case on a modern constant angular velocity
      disk drive.</dd>
  <dt id="metaslab_unload_delay"><a class="permalink" href="#metaslab_unload_delay"><b class="Sy">metaslab_unload_delay</b></a>=<b class="Sy">32</b>
    (int)</dt>
  <dd>After a metaslab is used, we keep it loaded for this many TXGs, to attempt
      to reduce unnecessary reloading. Note that both this many TXGs and
      <b class="Sy">metaslab_unload_delay_ms</b> milliseconds must pass before
      unloading will occur.</dd>
  <dt id="metaslab_unload_delay_ms"><a class="permalink" href="#metaslab_unload_delay_ms"><b class="Sy">metaslab_unload_delay_ms</b></a>=<b class="Sy">600000</b>ms
    (10min) (int)</dt>
  <dd>After a metaslab is used, we keep it loaded for this many milliseconds, to
      attempt to reduce unnecessary reloading. Note, that both this many
      milliseconds and <b class="Sy">metaslab_unload_delay</b> TXGs must pass
      before unloading will occur.</dd>
  <dt id="reference_history"><a class="permalink" href="#reference_history"><b class="Sy">reference_history</b></a>=<b class="Sy">3</b>
    (int)</dt>
  <dd>Maximum reference holders being tracked when reference_tracking_enable is
      active.</dd>
  <dt id="reference_tracking_enable"><a class="permalink" href="#reference_tracking_enable"><b class="Sy">reference_tracking_enable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Track reference holders to
      <a class="permalink" href="#refcount_t"><b class="Sy" id="refcount_t">refcount_t</b></a>
      objects (debug builds only).</dd>
  <dt id="send_holes_without_birth_time"><a class="permalink" href="#send_holes_without_birth_time"><b class="Sy">send_holes_without_birth_time</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>When set, the <b class="Sy">hole_birth</b> optimization will not be used,
      and all holes will always be sent during a <code class="Nm">zfs</code>
      <code class="Cm">send</code>. This is useful if you suspect your datasets
      are affected by a bug in <b class="Sy">hole_birth</b>.</dd>
  <dt id="spa_config_path"><a class="permalink" href="#spa_config_path"><b class="Sy">spa_config_path</b></a>=<span class="Pa">/etc/zfs/zpool.cache</span>
    (charp)</dt>
  <dd>SPA config file.</dd>
  <dt id="spa_asize_inflation"><a class="permalink" href="#spa_asize_inflation"><b class="Sy">spa_asize_inflation</b></a>=<a class="permalink" href="#24"><b class="Sy" id="24">24</b></a>
    (int)</dt>
  <dd>Multiplication factor used to estimate actual disk consumption from the
      size of data being written. The default value is a worst case estimate,
      but lower values may be valid for a given pool depending on its
      configuration. Pool administrators who understand the factors involved may
      wish to specify a more realistic inflation factor, particularly if they
      operate close to quota or capacity limits.</dd>
  <dt id="spa_load_print_vdev_tree"><a class="permalink" href="#spa_load_print_vdev_tree"><b class="Sy">spa_load_print_vdev_tree</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Whether to print the vdev tree in the debugging message buffer during pool
      import.</dd>
  <dt id="spa_load_verify_data"><a class="permalink" href="#spa_load_verify_data"><b class="Sy">spa_load_verify_data</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Whether to traverse data blocks during an &quot;extreme rewind&quot;
      (<code class="Fl">-X</code>) import.
    <p class="Pp">An extreme rewind import normally performs a full traversal of
        all blocks in the pool for verification. If this parameter is unset, the
        traversal skips non-metadata blocks. It can be toggled once the import
        has started to stop or start the traversal of non-metadata blocks.</p>
  </dd>
  <dt id="spa_load_verify_metadata"><a class="permalink" href="#spa_load_verify_metadata"><b class="Sy">spa_load_verify_metadata</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Whether to traverse blocks during an &quot;extreme rewind&quot;
      (<code class="Fl">-X</code>) pool import.
    <p class="Pp">An extreme rewind import normally performs a full traversal of
        all blocks in the pool for verification. If this parameter is unset, the
        traversal is not performed. It can be toggled once the import has
        started to stop or start the traversal.</p>
  </dd>
  <dt id="spa_load_verify_shift"><a class="permalink" href="#spa_load_verify_shift"><b class="Sy">spa_load_verify_shift</b></a>=<b class="Sy">4</b>
    (1/16th) (int)</dt>
  <dd>Sets the maximum number of bytes to consume during pool import to the log2
      fraction of the target ARC size.</dd>
  <dt id="spa_slop_shift"><a class="permalink" href="#spa_slop_shift"><b class="Sy">spa_slop_shift</b></a>=<b class="Sy">5</b>
    (1/32nd) (int)</dt>
  <dd>Normally, we don't allow the last
      <a class="permalink" href="#3.2_"><b class="Sy" id="3.2_">3.2%</b></a>
      (<a class="permalink" href="#1/2_spa_slop_shift"><b class="Sy" id="1/2_spa_slop_shift">1/2^spa_slop_shift</b></a>)
      of space in the pool to be consumed. This ensures that we don't run the
      pool completely out of space, due to unaccounted changes (e.g. to the
      MOS). It also limits the worst-case time to allocate space. If we have
      less than this amount of free space, most ZPL operations (e.g. write,
      create) will return
      <a class="permalink" href="#ENOSPC"><b class="Sy" id="ENOSPC">ENOSPC</b></a>.</dd>
  <dt id="vdev_removal_max_span"><a class="permalink" href="#vdev_removal_max_span"><b class="Sy">vdev_removal_max_span</b></a>=<b class="Sy">32768</b>B
    (32kB) (int)</dt>
  <dd>During top-level vdev removal, chunks of data are copied from the vdev
      which may include free space in order to trade bandwidth for IOPS. This
      parameter determines the maximum span of free space, in bytes, which will
      be included as &quot;unnecessary&quot; data in a chunk of copied data.
    <p class="Pp">The default value here was chosen to align with
        <b class="Sy">zfs_vdev_read_gap_limit</b>, which is a similar concept
        when doing regular reads (but there's no reason it has to be the
      same).</p>
  </dd>
  <dt id="vdev_file_logical_ashift"><a class="permalink" href="#vdev_file_logical_ashift"><b class="Sy">vdev_file_logical_ashift</b></a>=<b class="Sy">9</b>
    (512B) (ulong)</dt>
  <dd>Logical ashift for file-based devices.</dd>
  <dt id="vdev_file_physical_ashift"><a class="permalink" href="#vdev_file_physical_ashift"><b class="Sy">vdev_file_physical_ashift</b></a>=<b class="Sy">9</b>
    (512B) (ulong)</dt>
  <dd>Physical ashift for file-based devices.</dd>
  <dt id="zap_iterate_prefetch"><a class="permalink" href="#zap_iterate_prefetch"><b class="Sy">zap_iterate_prefetch</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>If set, when we start iterating over a ZAP object, prefetch the entire
      object (all leaf blocks). However, this is limited by
      <b class="Sy">dmu_prefetch_max</b>.</dd>
  <dt id="zfetch_array_rd_sz"><a class="permalink" href="#zfetch_array_rd_sz"><b class="Sy">zfetch_array_rd_sz</b></a>=<b class="Sy">1048576</b>B
    (1MB) (ulong)</dt>
  <dd>If prefetching is enabled, disable prefetching for reads larger than this
      size.</dd>
  <dt id="zfetch_min_distance"><a class="permalink" href="#zfetch_min_distance"><b class="Sy">zfetch_min_distance</b></a>=<b class="Sy">4194304</b>B
    (4 MiB) (uint)</dt>
  <dd>Min bytes to prefetch per stream. Prefetch distance starts from the demand
      access size and quickly grows to this value, doubling on each hit. After
      that it may grow further by 1/8 per hit, but only if some prefetch since
      last time haven't completed in time to satisfy demand request, i.e.
      prefetch depth didn't cover the read latency or the pool got
    saturated.</dd>
  <dt id="zfetch_max_distance"><a class="permalink" href="#zfetch_max_distance"><b class="Sy">zfetch_max_distance</b></a>=<b class="Sy">67108864</b>B
    (64 MiB) (uint)</dt>
  <dd>Max bytes to prefetch per stream.</dd>
  <dt id="zfetch_max_idistance"><a class="permalink" href="#zfetch_max_idistance"><b class="Sy">zfetch_max_idistance</b></a>=<b class="Sy">67108864</b>B
    (64MB) (uint)</dt>
  <dd>Max bytes to prefetch indirects for per stream.</dd>
  <dt id="zfetch_max_streams"><a class="permalink" href="#zfetch_max_streams"><b class="Sy">zfetch_max_streams</b></a>=<b class="Sy">8</b>
    (uint)</dt>
  <dd>Max number of streams per zfetch (prefetch streams per file).</dd>
  <dt id="zfetch_min_sec_reap"><a class="permalink" href="#zfetch_min_sec_reap"><b class="Sy">zfetch_min_sec_reap</b></a>=<b class="Sy">1</b>
    (uint)</dt>
  <dd>Min time before inactive prefetch stream can be reclaimed</dd>
  <dt id="zfetch_max_sec_reap"><a class="permalink" href="#zfetch_max_sec_reap"><b class="Sy">zfetch_max_sec_reap</b></a>=<b class="Sy">2</b>
    (uint)</dt>
  <dd>Max time before inactive prefetch stream can be deleted</dd>
  <dt id="zfs_abd_scatter_enabled"><a class="permalink" href="#zfs_abd_scatter_enabled"><b class="Sy">zfs_abd_scatter_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enables ARC from using scatter/gather lists and forces all allocations to
      be linear in kernel memory. Disabling can improve performance in some code
      paths at the expense of fragmented kernel memory.</dd>
  <dt id="zfs_abd_scatter_max_order"><a class="permalink" href="#zfs_abd_scatter_max_order"><b class="Sy">zfs_abd_scatter_max_order</b></a>=<a class="permalink" href="#MAX_ORDER-1"><b class="Sy" id="MAX_ORDER-1">MAX_ORDER-1</b></a>
    (uint)</dt>
  <dd>Maximum number of consecutive memory pages allocated in a single block for
      scatter/gather lists.
    <p class="Pp" id="MAX_ORDER">The value of
        <a class="permalink" href="#MAX_ORDER"><b class="Sy">MAX_ORDER</b></a>
        depends on kernel configuration.</p>
  </dd>
  <dt id="zfs_abd_scatter_min_size"><a class="permalink" href="#zfs_abd_scatter_min_size"><b class="Sy">zfs_abd_scatter_min_size</b></a>=<a class="permalink" href="#1536"><b class="Sy" id="1536">1536</b></a>B
    (1.5kB) (uint)</dt>
  <dd>This is the minimum allocation size that will use scatter (page-based)
      ABDs. Smaller allocations will use linear ABDs.</dd>
  <dt id="zfs_arc_dnode_limit"><a class="permalink" href="#zfs_arc_dnode_limit"><b class="Sy">zfs_arc_dnode_limit</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>When the number of bytes consumed by dnodes in the ARC exceeds this number
      of bytes, try to unpin some of it in response to demand for non-metadata.
      This value acts as a ceiling to the amount of dnode metadata, and defaults
      to <b class="Sy">0</b>, which indicates that a percent which is based on
      <b class="Sy">zfs_arc_dnode_limit_percent</b> of the ARC meta buffers that
      may be used for dnodes.
    <p class="Pp">Also see <b class="Sy">zfs_arc_meta_prune</b> which serves a
        similar purpose but is used when the amount of metadata in the ARC
        exceeds <b class="Sy">zfs_arc_meta_limit</b> rather than in response to
        overall demand for non-metadata.</p>
  </dd>
  <dt id="zfs_arc_dnode_limit_percent"><a class="permalink" href="#zfs_arc_dnode_limit_percent"><b class="Sy">zfs_arc_dnode_limit_percent</b></a>=<b class="Sy">10</b>%
    (ulong)</dt>
  <dd>Percentage that can be consumed by dnodes of ARC meta buffers.
    <p class="Pp">See also <b class="Sy">zfs_arc_dnode_limit</b>, which serves a
        similar purpose but has a higher priority if nonzero.</p>
  </dd>
  <dt id="zfs_arc_dnode_reduce_percent"><a class="permalink" href="#zfs_arc_dnode_reduce_percent"><b class="Sy">zfs_arc_dnode_reduce_percent</b></a>=<b class="Sy">10</b>%
    (ulong)</dt>
  <dd>Percentage of ARC dnodes to try to scan in response to demand for
      non-metadata when the number of bytes consumed by dnodes exceeds
      <b class="Sy">zfs_arc_dnode_limit</b>.</dd>
  <dt id="zfs_arc_average_blocksize"><a class="permalink" href="#zfs_arc_average_blocksize"><b class="Sy">zfs_arc_average_blocksize</b></a>=<a class="permalink" href="#8192"><b class="Sy" id="8192">8192</b></a>B
    (8kB) (int)</dt>
  <dd>The ARC's buffer hash table is sized based on the assumption of an average
      block size of this value. This works out to roughly 1MB of hash table per
      1GB of physical memory with 8-byte pointers. For configurations with a
      known larger average block size, this value can be increased to reduce the
      memory footprint.</dd>
  <dt id="zfs_arc_eviction_pct"><a class="permalink" href="#zfs_arc_eviction_pct"><b class="Sy">zfs_arc_eviction_pct</b></a>=<b class="Sy">200</b>%
    (int)</dt>
  <dd>When
      <a class="permalink" href="#arc_is_overflowing"><code class="Fn" id="arc_is_overflowing">arc_is_overflowing</code></a>(),
      <a class="permalink" href="#arc_get_data_impl"><code class="Fn" id="arc_get_data_impl">arc_get_data_impl</code></a>()
      waits for this percent of the requested amount of data to be evicted. For
      example, by default, for every
      <a class="permalink" href="#2kB"><i class="Em" id="2kB">2kB</i></a> that's
      evicted,
      <a class="permalink" href="#1kB"><i class="Em" id="1kB">1kB</i></a> of it
      may be &quot;reused&quot; by a new allocation. Since this is above
      <b class="Sy">100</b>%, it ensures that progress is made towards getting
      <b class="Sy">arc_size</b> <span class="No">under</span>
      <b class="Sy">arc_c</b>. Since this is finite, it ensures that allocations
      can still happen, even during the potentially long time that
      <b class="Sy">arc_size</b> <span class="No">is more than</span>
      <b class="Sy">arc_c</b>.</dd>
  <dt id="zfs_arc_evict_batch_limit"><a class="permalink" href="#zfs_arc_evict_batch_limit"><b class="Sy">zfs_arc_evict_batch_limit</b></a>=<b class="Sy">10</b>
    (int)</dt>
  <dd>Number ARC headers to evict per sub-list before proceeding to another
      sub-list. This batch-style operation prevents entire sub-lists from being
      evicted at once but comes at a cost of additional unlocking and
    locking.</dd>
  <dt id="zfs_arc_grow_retry"><a class="permalink" href="#zfs_arc_grow_retry"><b class="Sy">zfs_arc_grow_retry</b></a>=<b class="Sy">0</b>s
    (int)</dt>
  <dd>If set to a non zero value, it will replace the
      <b class="Sy">arc_grow_retry</b> value with this value. The
      <b class="Sy">arc_grow_retry</b> <span class="No">value</span> (default
      <b class="Sy">5</b>s) is the number of seconds the ARC will wait before
      trying to resume growth after a memory pressure event.</dd>
  <dt id="zfs_arc_lotsfree_percent"><a class="permalink" href="#zfs_arc_lotsfree_percent"><b class="Sy">zfs_arc_lotsfree_percent</b></a>=<b class="Sy">10</b>%
    (int)</dt>
  <dd>Throttle I/O when free system memory drops below this percentage of total
      system memory. Setting this value to <b class="Sy">0</b> will disable the
      throttle.</dd>
  <dt id="zfs_arc_max"><a class="permalink" href="#zfs_arc_max"><b class="Sy">zfs_arc_max</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>Max size of ARC in bytes. If <b class="Sy">0</b>, then the max size of ARC
      is determined by the amount of system memory installed. Under Linux, half
      of system memory will be used as the limit. Under
      <span class="Ux">FreeBSD</span>, the larger of
      <a class="permalink" href="#all_system_memory"><b class="Sy" id="all_system_memory">all_system_memory
      - 1GB</b></a> <span class="No">and</span>
      <a class="permalink" href="#5/8"><b class="Sy" id="5/8">5/8 *
      all_system_memory</b></a> will be used as the limit. This value must be at
      least <b class="Sy">67108864</b>B (64MB).
    <p class="Pp">This value can be changed dynamically, with some caveats. It
        cannot be set back to <b class="Sy">0</b> while running, and reducing it
        below the current ARC size will not cause the ARC to shrink without
        memory pressure to induce shrinking.</p>
  </dd>
  <dt id="zfs_arc_meta_adjust_restarts"><a class="permalink" href="#zfs_arc_meta_adjust_restarts"><b class="Sy">zfs_arc_meta_adjust_restarts</b></a>=<b class="Sy">4096</b>
    (ulong)</dt>
  <dd>The number of restart passes to make while scanning the ARC attempting the
      free buffers in order to stay below the
      <a class="permalink" href="#fs_arc_meta_limit"><b class="Sy" id="fs_arc_meta_limit">fs_arc_meta_limit</b></a>.
      This value should not need to be tuned but is available to facilitate
      performance analysis.</dd>
  <dt id="zfs_arc_meta_limit"><a class="permalink" href="#zfs_arc_meta_limit"><b class="Sy">zfs_arc_meta_limit</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>The maximum allowed size in bytes that metadata buffers are allowed to
      consume in the ARC. When this limit is reached, metadata buffers will be
      reclaimed, even if the overall
      <a class="permalink" href="#arc_c_max"><b class="Sy" id="arc_c_max">arc_c_max</b></a>
      has not been reached. It defaults to <b class="Sy">0</b>, which indicates
      that a percentage based on <b class="Sy">zfs_arc_meta_limit_percent</b> of
      the ARC may be used for metadata.
    <p class="Pp">This value my be changed dynamically, except that must be set
        to an explicit value (cannot be set back to <b class="Sy">0</b>).</p>
  </dd>
  <dt id="zfs_arc_meta_limit_percent"><a class="permalink" href="#zfs_arc_meta_limit_percent"><b class="Sy">zfs_arc_meta_limit_percent</b></a>=<b class="Sy">75</b>%
    (ulong)</dt>
  <dd>Percentage of ARC buffers that can be used for metadata.
    <p class="Pp">See also <b class="Sy">zfs_arc_meta_limit</b>, which serves a
        similar purpose but has a higher priority if nonzero.</p>
  </dd>
  <dt id="zfs_arc_meta_min"><a class="permalink" href="#zfs_arc_meta_min"><b class="Sy">zfs_arc_meta_min</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>The minimum allowed size in bytes that metadata buffers may consume in the
      ARC.</dd>
  <dt id="zfs_arc_meta_prune"><a class="permalink" href="#zfs_arc_meta_prune"><b class="Sy">zfs_arc_meta_prune</b></a>=<b class="Sy">10000</b>
    (int)</dt>
  <dd>The number of dentries and inodes to be scanned looking for entries which
      can be dropped. This may be required when the ARC reaches the
      <b class="Sy">zfs_arc_meta_limit</b> because dentries and inodes can pin
      buffers in the ARC. Increasing this value will cause to dentry and inode
      caches to be pruned more aggressively. Setting this value to
      <b class="Sy">0</b> will disable pruning the inode and dentry caches.</dd>
  <dt id="zfs_arc_meta_strategy"><a class="permalink" href="#zfs_arc_meta_strategy"><b class="Sy">zfs_arc_meta_strategy</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Define the strategy for ARC metadata buffer eviction (meta reclaim
      strategy):
    <div class="Bd-indent">
    <dl class="Bl-tag Bl-compact">
      <dt id="0"><a class="permalink" href="#0"><b class="Sy">0</b></a>
        (META_ONLY)</dt>
      <dd>evict only the ARC metadata buffers</dd>
      <dt id="1"><a class="permalink" href="#1"><b class="Sy">1</b></a>
        (BALANCED)</dt>
      <dd>additional data buffers may be evicted if required to evict the
          required number of metadata buffers.</dd>
    </dl>
    </div>
  </dd>
  <dt id="zfs_arc_min"><a class="permalink" href="#zfs_arc_min"><b class="Sy">zfs_arc_min</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>Min size of ARC in bytes. <span class="No">If set to</span>
      <b class="Sy">0</b>,
      <a class="permalink" href="#arc_c_min"><b class="Sy" id="arc_c_min">arc_c_min</b></a>
      will default to consuming the larger of <b class="Sy">32MB</b>
      <span class="No">or</span>
      <a class="permalink" href="#all_system_memory/32"><b class="Sy" id="all_system_memory/32">all_system_memory/32</b></a>.</dd>
  <dt id="zfs_arc_min_prefetch_ms"><a class="permalink" href="#zfs_arc_min_prefetch_ms"><b class="Sy">zfs_arc_min_prefetch_ms</b></a>=<b class="Sy">0</b>ms(&#x2261;1s)
    (int)</dt>
  <dd>Minimum time prefetched blocks are locked in the ARC.</dd>
  <dt id="zfs_arc_min_prescient_prefetch_ms"><a class="permalink" href="#zfs_arc_min_prescient_prefetch_ms"><b class="Sy">zfs_arc_min_prescient_prefetch_ms</b></a>=<b class="Sy">0</b>ms(&#x2261;6s)
    (int)</dt>
  <dd>Minimum time &quot;prescient prefetched&quot; blocks are locked in the
      ARC. These blocks are meant to be prefetched fairly aggressively ahead of
      the code that may use them.</dd>
  <dt id="zfs_arc_prune_task_threads"><a class="permalink" href="#zfs_arc_prune_task_threads"><b class="Sy">zfs_arc_prune_task_threads</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Number of arc_prune threads. <span class="Ux">FreeBSD</span> does not need
      more than one. Linux may theoretically use one per mount point up to
      number of CPUs, but that was not proven to be useful.</dd>
  <dt id="zfs_max_missing_tvds"><a class="permalink" href="#zfs_max_missing_tvds"><b class="Sy">zfs_max_missing_tvds</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Number of missing top-level vdevs which will be allowed during pool import
      (only in read-only mode).</dd>
  <dt id="zfs_max_nvlist_src_size"><a class="permalink" href="#zfs_max_nvlist_src_size"><b class="Sy">zfs_max_nvlist_src_size</b></a>=
    <b class="Sy">0</b> (ulong)</dt>
  <dd>Maximum size in bytes allowed to be passed as
      <a class="permalink" href="#zc_nvlist_src_size"><b class="Sy" id="zc_nvlist_src_size">zc_nvlist_src_size</b></a>
      for ioctls on <span class="Pa">/dev/zfs</span>. This prevents a user from
      causing the kernel to allocate an excessive amount of memory. When the
      limit is exceeded, the ioctl fails with
      <a class="permalink" href="#EINVAL"><b class="Sy" id="EINVAL">EINVAL</b></a>
      and a description of the error is sent to the
      <span class="Pa">zfs-dbgmsg</span> log. This parameter should not need to
      be touched under normal circumstances. If <b class="Sy">0</b>, equivalent
      to a quarter of the user-wired memory limit under
      <span class="Ux">FreeBSD</span> and to <b class="Sy">134217728</b>B
      (128MB) under Linux.</dd>
  <dt id="zfs_multilist_num_sublists"><a class="permalink" href="#zfs_multilist_num_sublists"><b class="Sy">zfs_multilist_num_sublists</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>To allow more fine-grained locking, each ARC state contains a series of
      lists for both data and metadata objects. Locking is performed at the
      level of these &quot;sub-lists&quot;. This parameters controls the number
      of sub-lists per ARC state, and also applies to other uses of the
      multilist data structure.
    <p class="Pp">If <b class="Sy">0</b>, equivalent to the greater of the
        number of online CPUs and <b class="Sy">4</b>.</p>
  </dd>
  <dt id="zfs_arc_overflow_shift"><a class="permalink" href="#zfs_arc_overflow_shift"><b class="Sy">zfs_arc_overflow_shift</b></a>=<b class="Sy">8</b>
    (int)</dt>
  <dd>The ARC size is considered to be overflowing if it exceeds the current ARC
      target size (<b class="Sy">arc_c</b>) by thresholds determined by this
      parameter. Exceeding by (<b class="Sy">arc_c &gt;&gt;
      zfs_arc_overflow_shift</b>) <b class="Sy">* 0.5</b> starts ARC reclamation
      process. If that appears insufficient, exceeding by (<b class="Sy">arc_c
      &gt;&gt; zfs_arc_overflow_shift</b>) <b class="Sy">* 1.5</b> blocks new
      buffer allocation until the reclaim thread catches up. Started reclamation
      process continues till ARC size returns below the target size.
    <p class="Pp" id="0.2_">The default value of <b class="Sy">8</b> causes the
        ARC to start reclamation if it exceeds the target size by
        <a class="permalink" href="#0.2_"><i class="Em">0.2%</i></a> of the
        target size, and block allocations by
        <a class="permalink" href="#0.6_"><i class="Em" id="0.6_">0.6%</i></a>.</p>
  </dd>
  <dt id="zfs_arc_p_min_shift"><a class="permalink" href="#zfs_arc_p_min_shift"><b class="Sy">zfs_arc_p_min_shift</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>If nonzero, this will update <b class="Sy">arc_p_min_shift</b> (default
      <b class="Sy">4</b>) with the new value. <b class="Sy">arc_p_min_shift</b>
      <span class="No">is used as a shift of</span> <b class="Sy">arc_c</b> when
      calculating the minumum <b class="Sy">arc_p</b>
      <span class="No">size.</span></dd>
  <dt id="zfs_arc_p_dampener_disable"><a class="permalink" href="#zfs_arc_p_dampener_disable"><b class="Sy">zfs_arc_p_dampener_disable</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Disable <b class="Sy">arc_p</b> adapt dampener, which reduces the maximum
      single adjustment to <b class="Sy">arc_p</b>.</dd>
  <dt id="zfs_arc_shrink_shift"><a class="permalink" href="#zfs_arc_shrink_shift"><b class="Sy">zfs_arc_shrink_shift</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>If nonzero, this will update
      <a class="permalink" href="#arc_shrink_shift"><b class="Sy" id="arc_shrink_shift">arc_shrink_shift</b></a>
      (default <b class="Sy">7</b>) with the new value.</dd>
  <dt id="zfs_arc_pc_percent"><a class="permalink" href="#zfs_arc_pc_percent"><b class="Sy">zfs_arc_pc_percent</b></a>=<b class="Sy">0</b>%
    (off) (uint)</dt>
  <dd>Percent of pagecache to reclaim ARC to.
    <p class="Pp" id="NR_FILE_PAGES">This tunable allows the ZFS ARC to play
        more nicely with the kernel's LRU pagecache. It can guarantee that the
        ARC size won't collapse under scanning pressure on the pagecache, yet
        still allows the ARC to be reclaimed down to
        <b class="Sy">zfs_arc_min</b> if necessary. This value is specified as
        percent of pagecache size (as measured by
        <a class="permalink" href="#NR_FILE_PAGES"><b class="Sy">NR_FILE_PAGES</b></a>),
        where that percent may exceed <b class="Sy">100</b>. This only operates
        during memory pressure/reclaim.</p>
  </dd>
  <dt id="zfs_arc_shrinker_limit"><a class="permalink" href="#zfs_arc_shrinker_limit"><b class="Sy">zfs_arc_shrinker_limit</b></a>=<b class="Sy">10000</b>
    (int)</dt>
  <dd>This is a limit on how many pages the ARC shrinker makes available for
      eviction in response to one page allocation attempt. Note that in
      practice, the kernel's shrinker can ask us to evict up to about four times
      this for one allocation attempt.
    <p class="Pp" id="160MB">The default limit of <b class="Sy">10000</b> (in
        practice, <a class="permalink" href="#160MB"><i class="Em">160MB</i></a>
        <span class="No">per allocation attempt with 4kB pages</span>) limits
        the amount of time spent attempting to reclaim ARC memory to less than
        100ms per allocation attempt, even with a small average compressed block
        size of ~8kB.</p>
    <p class="Pp">The parameter can be set to 0 (zero) to disable the limit, and
        only applies on Linux.</p>
  </dd>
  <dt id="zfs_arc_sys_free"><a class="permalink" href="#zfs_arc_sys_free"><b class="Sy">zfs_arc_sys_free</b></a>=<b class="Sy">0</b>B
    (ulong)</dt>
  <dd>The target number of bytes the ARC should leave as free memory on the
      system. If zero, equivalent to the bigger of
      <a class="permalink" href="#512kB"><b class="Sy" id="512kB">512kB</b></a>
      <span class="No">and</span>
      <a class="permalink" href="#all_system_memory/64"><b class="Sy" id="all_system_memory/64">all_system_memory/64</b></a>.</dd>
  <dt id="zfs_autoimport_disable"><a class="permalink" href="#zfs_autoimport_disable"><b class="Sy">zfs_autoimport_disable</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Disable pool import at module load by ignoring the cache file
      (<b class="Sy">spa_config_path</b>).</dd>
  <dt id="zfs_checksum_events_per_second"><a class="permalink" href="#zfs_checksum_events_per_second"><b class="Sy">zfs_checksum_events_per_second</b></a>=<b class="Sy">20</b>/s
    (uint)</dt>
  <dd>Rate limit checksum events to this many per second. Note that this should
      not be set below the ZED thresholds (currently 10 checksums over 10
      seconds) or else the daemon may not trigger any action.</dd>
  <dt id="zfs_commit_timeout_pct"><a class="permalink" href="#zfs_commit_timeout_pct"><b class="Sy">zfs_commit_timeout_pct</b></a>=<b class="Sy">5</b>%
    (int)</dt>
  <dd>This controls the amount of time that a ZIL block (lwb) will remain
      &quot;open&quot; when it isn't &quot;full&quot;, and it has a thread
      waiting for it to be committed to stable storage. The timeout is scaled
      based on a percentage of the last lwb latency to avoid significantly
      impacting the latency of each individual transaction record (itx).</dd>
  <dt id="zfs_condense_indirect_commit_entry_delay_ms"><a class="permalink" href="#zfs_condense_indirect_commit_entry_delay_ms"><b class="Sy">zfs_condense_indirect_commit_entry_delay_ms</b></a>=<b class="Sy">0</b>ms
    (int)</dt>
  <dd>Vdev indirection layer (used for device removal) sleeps for this many
      milliseconds during mapping generation. Intended for use with the test
      suite to throttle vdev removal speed.</dd>
  <dt id="zfs_condense_indirect_obsolete_pct"><a class="permalink" href="#zfs_condense_indirect_obsolete_pct"><b class="Sy">zfs_condense_indirect_obsolete_pct</b></a>=<b class="Sy">25</b>%
    (int)</dt>
  <dd>Minimum percent of obsolete bytes in vdev mapping required to attempt to
      condense (see <b class="Sy">zfs_condense_indirect_vdevs_enable</b>).
      Intended for use with the test suite to facilitate triggering condensing
      as needed.</dd>
  <dt id="zfs_condense_indirect_vdevs_enable"><a class="permalink" href="#zfs_condense_indirect_vdevs_enable"><b class="Sy">zfs_condense_indirect_vdevs_enable</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable condensing indirect vdev mappings. When set, attempt to condense
      indirect vdev mappings if the mapping uses more than
      <b class="Sy">zfs_condense_min_mapping_bytes</b> bytes of memory and if
      the obsolete space map object uses more than
      <b class="Sy">zfs_condense_max_obsolete_bytes</b> bytes on-disk. The
      condensing process is an attempt to save memory by removing obsolete
      mappings.</dd>
  <dt id="zfs_condense_max_obsolete_bytes"><a class="permalink" href="#zfs_condense_max_obsolete_bytes"><b class="Sy">zfs_condense_max_obsolete_bytes</b></a>=<b class="Sy">1073741824</b>B
    (1GB) (ulong)</dt>
  <dd>Only attempt to condense indirect vdev mappings if the on-disk size of the
      obsolete space map object is greater than this number of bytes (see
      <b class="Sy">zfs_condense_indirect_vdevs_enable</b>).</dd>
  <dt id="zfs_condense_min_mapping_bytes"><a class="permalink" href="#zfs_condense_min_mapping_bytes"><b class="Sy">zfs_condense_min_mapping_bytes</b></a>=<b class="Sy">131072</b>B
    (128kB) (ulong)</dt>
  <dd>Minimum size vdev mapping to attempt to condense (see
      <b class="Sy">zfs_condense_indirect_vdevs_enable</b>).</dd>
  <dt id="zfs_dbgmsg_enable"><a class="permalink" href="#zfs_dbgmsg_enable"><b class="Sy">zfs_dbgmsg_enable</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Internally ZFS keeps a small log to facilitate debugging. The log is
      enabled by default, and can be disabled by unsetting this option. The
      contents of the log can be accessed by reading
      <span class="Pa">/proc/spl/kstat/zfs/dbgmsg</span>. Writing
      <b class="Sy">0</b> to the file clears the log.
    <p class="Pp">This setting does not influence debug prints due to
        <b class="Sy">zfs_flags</b>.</p>
  </dd>
  <dt id="zfs_dbgmsg_maxsize"><a class="permalink" href="#zfs_dbgmsg_maxsize"><b class="Sy">zfs_dbgmsg_maxsize</b></a>=<b class="Sy">4194304</b>B
    (4MB) (int)</dt>
  <dd>Maximum size of the internal ZFS debug log.</dd>
  <dt id="zfs_dbuf_state_index"><a class="permalink" href="#zfs_dbuf_state_index"><b class="Sy">zfs_dbuf_state_index</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Historically used for controlling what reporting was available under
      <span class="Pa">/proc/spl/kstat/zfs</span>. No effect.</dd>
  <dt id="zfs_deadman_enabled"><a class="permalink" href="#zfs_deadman_enabled"><b class="Sy">zfs_deadman_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>When a pool sync operation takes longer than
      <b class="Sy">zfs_deadman_synctime_ms</b>, or when an individual I/O
      operation takes longer than <b class="Sy">zfs_deadman_ziotime_ms</b>, then
      the operation is considered to be &quot;hung&quot;. If
      <b class="Sy">zfs_deadman_enabled</b> is set, then the deadman behavior is
      invoked as described by <b class="Sy">zfs_deadman_failmode</b>. By
      default, the deadman is enabled and set to <b class="Sy">wait</b> which
      results in &quot;hung&quot; I/Os only being logged. The deadman is
      automatically disabled when a pool gets suspended.</dd>
  <dt id="zfs_deadman_failmode"><a class="permalink" href="#zfs_deadman_failmode"><b class="Sy">zfs_deadman_failmode</b></a>=<b class="Sy">wait</b>
    (charp)</dt>
  <dd>Controls the failure behavior when the deadman detects a &quot;hung&quot;
      I/O operation. Valid values are:
    <div class="Bd-indent">
    <dl class="Bl-tag Bl-compact">
      <dt id="wait"><a class="permalink" href="#wait"><b class="Sy">wait</b></a></dt>
      <dd>Wait for a &quot;hung&quot; operation to complete. For each
          &quot;hung&quot; operation a &quot;deadman&quot; event will be posted
          describing that operation.</dd>
      <dt id="continue"><a class="permalink" href="#continue"><b class="Sy">continue</b></a></dt>
      <dd>Attempt to recover from a &quot;hung&quot; operation by re-dispatching
          it to the I/O pipeline if possible.</dd>
      <dt id="panic"><a class="permalink" href="#panic"><b class="Sy">panic</b></a></dt>
      <dd>Panic the system. This can be used to facilitate automatic fail-over
          to a properly configured fail-over partner.</dd>
    </dl>
    </div>
  </dd>
  <dt id="zfs_deadman_checktime_ms"><a class="permalink" href="#zfs_deadman_checktime_ms"><b class="Sy">zfs_deadman_checktime_ms</b></a>=<a class="permalink" href="#60000"><b class="Sy" id="60000">60000</b></a>ms
    (1min) (int)</dt>
  <dd>Check time in milliseconds. This defines the frequency at which we check
      for hung I/O requests and potentially invoke the
      <b class="Sy">zfs_deadman_failmode</b> behavior.</dd>
  <dt id="zfs_deadman_synctime_ms"><a class="permalink" href="#zfs_deadman_synctime_ms"><b class="Sy">zfs_deadman_synctime_ms</b></a>=<b class="Sy">600000</b>ms
    (10min) (ulong)</dt>
  <dd>Interval in milliseconds after which the deadman is triggered and also the
      interval after which a pool sync operation is considered to be
      &quot;hung&quot;. Once this limit is exceeded the deadman will be invoked
      every <b class="Sy">zfs_deadman_checktime_ms</b> milliseconds until the
      pool sync completes.</dd>
  <dt id="zfs_deadman_ziotime_ms"><a class="permalink" href="#zfs_deadman_ziotime_ms"><b class="Sy">zfs_deadman_ziotime_ms</b></a>=<a class="permalink" href="#300000"><b class="Sy" id="300000">300000</b></a>ms
    (5min) (ulong)</dt>
  <dd>Interval in milliseconds after which the deadman is triggered and an
      individual I/O operation is considered to be &quot;hung&quot;. As long as
      the operation remains &quot;hung&quot;, the deadman will be invoked every
      <b class="Sy">zfs_deadman_checktime_ms</b> milliseconds until the
      operation completes.</dd>
  <dt id="zfs_dedup_prefetch"><a class="permalink" href="#zfs_dedup_prefetch"><b class="Sy">zfs_dedup_prefetch</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Enable prefetching dedup-ed blocks which are going to be freed.</dd>
  <dt id="zfs_delay_min_dirty_percent"><a class="permalink" href="#zfs_delay_min_dirty_percent"><b class="Sy">zfs_delay_min_dirty_percent</b></a>=<b class="Sy">60</b>%
    (int)</dt>
  <dd>Start to delay each transaction once there is this amount of dirty data,
      expressed as a percentage of <b class="Sy">zfs_dirty_data_max</b>. This
      value should be at least
      <b class="Sy">zfs_vdev_async_write_active_max_dirty_percent</b>.
      <span class="No">See</span>
      <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION
    DELAY</a>.</dd>
  <dt id="zfs_delay_scale"><a class="permalink" href="#zfs_delay_scale"><b class="Sy">zfs_delay_scale</b></a>=<b class="Sy">500000</b>
    (int)</dt>
  <dd>This controls how quickly the transaction delay approaches infinity.
      Larger values cause longer delays for a given amount of dirty data.
    <p class="Pp">For the smoothest delay, this value should be about 1 billion
        divided by the maximum number of operations per second. This will
        smoothly handle between ten times and a tenth of this number.
        <span class="No">See</span>
        <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION
      DELAY</a>.</p>
    <p class="Pp" id="must"><b class="Sy">zfs_delay_scale *
        zfs_dirty_data_max</b>
        <a class="permalink" href="#must"><i class="Em">must be smaller
        than</i></a>
        <a class="permalink" href="#2_64"><b class="Sy" id="2_64">2^64</b></a>.</p>
  </dd>
  <dt id="zfs_disable_ivset_guid_check"><a class="permalink" href="#zfs_disable_ivset_guid_check"><b class="Sy">zfs_disable_ivset_guid_check</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disables requirement for IVset GUIDs to be present and match when doing a
      raw receive of encrypted datasets. Intended for users whose pools were
      created with OpenZFS pre-release versions and now have compatibility
      issues.</dd>
  <dt id="zfs_key_max_salt_uses"><a class="permalink" href="#zfs_key_max_salt_uses"><b class="Sy">zfs_key_max_salt_uses</b></a>=<a class="permalink" href="#400000000"><b class="Sy" id="400000000">400000000</b></a>
    (4*10^8) (ulong)</dt>
  <dd>Maximum number of uses of a single salt value before generating a new one
      for encrypted datasets. The default value is also the maximum.</dd>
  <dt id="zfs_object_mutex_size"><a class="permalink" href="#zfs_object_mutex_size"><b class="Sy">zfs_object_mutex_size</b></a>=<b class="Sy">64</b>
    (uint)</dt>
  <dd>Size of the znode hashtable used for holds.
    <p class="Pp">Due to the need to hold locks on objects that may not exist
        yet, kernel mutexes are not created per-object and instead a hashtable
        is used where collisions will result in objects waiting when there is
        not actually contention on the same object.</p>
  </dd>
  <dt id="zfs_slow_io_events_per_second"><a class="permalink" href="#zfs_slow_io_events_per_second"><b class="Sy">zfs_slow_io_events_per_second</b></a>=<b class="Sy">20</b>/s
    (int)</dt>
  <dd>Rate limit delay and deadman zevents (which report slow I/Os) to this many
      per second.</dd>
  <dt id="zfs_unflushed_max_mem_amt"><a class="permalink" href="#zfs_unflushed_max_mem_amt"><b class="Sy">zfs_unflushed_max_mem_amt</b></a>=<b class="Sy">1073741824</b>B
    (1GB) (ulong)</dt>
  <dd>Upper-bound limit for unflushed metadata changes to be held by the log
      spacemap in memory, in bytes.</dd>
  <dt id="zfs_unflushed_max_mem_ppm"><a class="permalink" href="#zfs_unflushed_max_mem_ppm"><b class="Sy">zfs_unflushed_max_mem_ppm</b></a>=<b class="Sy">1000</b>ppm
    (0.1%) (ulong)</dt>
  <dd>Part of overall system memory that ZFS allows to be used for unflushed
      metadata changes by the log spacemap, in millionths.</dd>
  <dt id="zfs_unflushed_log_block_max"><a class="permalink" href="#zfs_unflushed_log_block_max"><b class="Sy">zfs_unflushed_log_block_max</b></a>=<b class="Sy">131072</b>
    (128k) (ulong)</dt>
  <dd>Describes the maximum number of log spacemap blocks allowed for each pool.
      The default value means that the space in all the log spacemaps can add up
      to no more than <b class="Sy">131072</b> blocks (which means
      <a class="permalink" href="#16GB"><i class="Em" id="16GB">16GB</i></a> of
      logical space before compression and ditto blocks, assuming that blocksize
      is <i class="Em">128kB</i>).
    <p class="Pp">This tunable is important because it involves a trade-off
        between import time after an unclean export and the frequency of
        flushing metaslabs. The higher this number is, the more log blocks we
        allow when the pool is active which means that we flush metaslabs less
        often and thus decrease the number of I/Os for spacemap updates per TXG.
        At the same time though, that means that in the event of an unclean
        export, there will be more log spacemap blocks for us to read, inducing
        overhead in the import time of the pool. The lower the number, the
        amount of flushing increases, destroying log blocks quicker as they
        become obsolete faster, which leaves less blocks to be read during
        import time after a crash.</p>
    <p class="Pp">Each log spacemap block existing during pool import leads to
        approximately one extra logical I/O issued. This is the reason why this
        tunable is exposed in terms of blocks rather than space used.</p>
  </dd>
  <dt id="zfs_unflushed_log_block_min"><a class="permalink" href="#zfs_unflushed_log_block_min"><b class="Sy">zfs_unflushed_log_block_min</b></a>=<b class="Sy">1000</b>
    (ulong)</dt>
  <dd>If the number of metaslabs is small and our incoming rate is high, we
      could get into a situation that we are flushing all our metaslabs every
      TXG. Thus we always allow at least this many log blocks.</dd>
  <dt id="zfs_unflushed_log_block_pct"><a class="permalink" href="#zfs_unflushed_log_block_pct"><b class="Sy">zfs_unflushed_log_block_pct</b></a>=<a class="permalink" href="#400"><b class="Sy" id="400">400</b></a>%
    (ulong)</dt>
  <dd>Tunable used to determine the number of blocks that can be used for the
      spacemap log, expressed as a percentage of the total number of unflushed
      metaslabs in the pool.</dd>
  <dt id="zfs_unflushed_log_txg_max"><a class="permalink" href="#zfs_unflushed_log_txg_max"><b class="Sy">zfs_unflushed_log_txg_max</b></a>=<b class="Sy">1000</b>
    (ulong)</dt>
  <dd>Tunable limiting maximum time in TXGs any metaslab may remain unflushed.
      It effectively limits maximum number of unflushed per-TXG spacemap logs
      that need to be read after unclean pool export.</dd>
  <dt id="zfs_unlink_suspend_progress"><a class="permalink" href="#zfs_unlink_suspend_progress"><b class="Sy">zfs_unlink_suspend_progress</b></a>=<b class="Sy">0</b>|1
    (uint)</dt>
  <dd>When enabled, files will not be asynchronously removed from the list of
      pending unlinks and the space they consume will be leaked. Once this
      option has been disabled and the dataset is remounted, the pending unlinks
      will be processed and the freed space returned to the pool. This option is
      used by the test suite.</dd>
  <dt id="zfs_delete_blocks"><a class="permalink" href="#zfs_delete_blocks"><b class="Sy">zfs_delete_blocks</b></a>=<a class="permalink" href="#20480"><b class="Sy" id="20480">20480</b></a>
    (ulong)</dt>
  <dd>This is the used to define a large file for the purposes of deletion.
      Files containing more than <b class="Sy">zfs_delete_blocks</b> will be
      deleted asynchronously, while smaller files are deleted synchronously.
      Decreasing this value will reduce the time spent in an
      <a class="Xr">unlink(2)</a> system call, at the expense of a longer delay
      before the freed space is available.</dd>
  <dt id="zfs_dirty_data_max"><a class="permalink" href="#zfs_dirty_data_max"><b class="Sy">zfs_dirty_data_max</b></a>=
    (int)</dt>
  <dd>Determines the dirty space limit in bytes. Once this limit is exceeded,
      new writes are halted until space frees up. This parameter takes
      precedence over <b class="Sy">zfs_dirty_data_max_percent</b>.
      <span class="No">See</span>
      <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION DELAY</a>.
    <p class="Pp" id="physical_ram/10">Defaults to
        <a class="permalink" href="#physical_ram/10"><b class="Sy">physical_ram/10</b></a>,
        capped at <b class="Sy">zfs_dirty_data_max_max</b>.</p>
  </dd>
  <dt id="zfs_dirty_data_max_max"><a class="permalink" href="#zfs_dirty_data_max_max"><b class="Sy">zfs_dirty_data_max_max</b></a>=
    (int)</dt>
  <dd>Maximum allowable value of <b class="Sy">zfs_dirty_data_max</b>, expressed
      in bytes. This limit is only enforced at module load time, and will be
      ignored if <b class="Sy">zfs_dirty_data_max</b> is later changed. This
      parameter takes precedence over
      <b class="Sy">zfs_dirty_data_max_max_percent</b>.
      <span class="No">See</span>
      <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION DELAY</a>.
    <p class="Pp" id="physical_ram/4">Defaults to
        <a class="permalink" href="#physical_ram/4"><b class="Sy">physical_ram/4</b></a>,</p>
  </dd>
  <dt id="zfs_dirty_data_max_max_percent"><a class="permalink" href="#zfs_dirty_data_max_max_percent"><b class="Sy">zfs_dirty_data_max_max_percent</b></a>=<b class="Sy">25</b>%
    (int)</dt>
  <dd>Maximum allowable value of <b class="Sy">zfs_dirty_data_max</b>, expressed
      as a percentage of physical RAM. This limit is only enforced at module
      load time, and will be ignored if <b class="Sy">zfs_dirty_data_max</b> is
      later changed. The parameter <b class="Sy">zfs_dirty_data_max_max</b>
      takes precedence over this one. <span class="No">See</span>
      <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION
    DELAY</a>.</dd>
  <dt id="zfs_dirty_data_max_percent"><a class="permalink" href="#zfs_dirty_data_max_percent"><b class="Sy">zfs_dirty_data_max_percent</b></a>=<b class="Sy">10</b>%
    (int)</dt>
  <dd>Determines the dirty space limit, expressed as a percentage of all memory.
      Once this limit is exceeded, new writes are halted until space frees up.
      The parameter <b class="Sy">zfs_dirty_data_max</b> takes precedence over
      this one. <span class="No">See</span>
      <a class="Sx" href="#ZFS_TRANSACTION_DELAY">ZFS TRANSACTION DELAY</a>.
    <p class="Pp">Subject to <b class="Sy">zfs_dirty_data_max_max</b>.</p>
  </dd>
  <dt id="zfs_dirty_data_sync_percent"><a class="permalink" href="#zfs_dirty_data_sync_percent"><b class="Sy">zfs_dirty_data_sync_percent</b></a>=<b class="Sy">20</b>%
    (int)</dt>
  <dd>Start syncing out a transaction group if there's at least this much dirty
      data (as a percentage of <b class="Sy">zfs_dirty_data_max</b>). This
      should be less than
      <b class="Sy">zfs_vdev_async_write_active_min_dirty_percent</b>.</dd>
  <dt id="zfs_wrlog_data_max"><a class="permalink" href="#zfs_wrlog_data_max"><b class="Sy">zfs_wrlog_data_max</b></a>=
    (int)</dt>
  <dd>The upper limit of write-transaction zil log data size in bytes. Write
      operations are throttled when approaching the limit until log data is
      cleared out after transaction group sync. Because of some overhead, it
      should be set at least 2 times the size of
      <b class="Sy">zfs_dirty_data_max</b> <span class="No">to prevent harming
      normal write throughput.</span> It also should be smaller than the size of
      the slog device if slog is present.
    <p class="Pp" id="zfs_dirty_data_max*2">Defaults to
        <a class="permalink" href="#zfs_dirty_data_max*2"><b class="Sy">zfs_dirty_data_max*2</b></a></p>
  </dd>
  <dt id="zfs_fallocate_reserve_percent"><a class="permalink" href="#zfs_fallocate_reserve_percent"><b class="Sy">zfs_fallocate_reserve_percent</b></a>=<a class="permalink" href="#110"><b class="Sy" id="110">110</b></a>%
    (uint)</dt>
  <dd>Since ZFS is a copy-on-write filesystem with snapshots, blocks cannot be
      preallocated for a file in order to guarantee that later writes will not
      run out of space. Instead, <a class="Xr">fallocate(2)</a> space
      preallocation only checks that sufficient space is currently available in
      the pool or the user's project quota allocation, and then creates a sparse
      file of the requested size. The requested space is multiplied by
      <b class="Sy">zfs_fallocate_reserve_percent</b> to allow additional space
      for indirect blocks and other internal metadata. Setting this to
      <b class="Sy">0</b> disables support for <a class="Xr">fallocate(2)</a>
      and causes it to return
      <a class="permalink" href="#EOPNOTSUPP"><b class="Sy" id="EOPNOTSUPP">EOPNOTSUPP</b></a>.</dd>
  <dt id="zfs_fletcher_4_impl"><a class="permalink" href="#zfs_fletcher_4_impl"><b class="Sy">zfs_fletcher_4_impl</b></a>=<b class="Sy">fastest</b>
    (string)</dt>
  <dd>Select a fletcher 4 implementation.
    <p class="Pp" id="sse2">Supported selectors are: <b class="Sy">fastest</b>,
        <b class="Sy">scalar</b>,
        <a class="permalink" href="#sse2"><b class="Sy">sse2</b></a>,
        <a class="permalink" href="#ssse3"><b class="Sy" id="ssse3">ssse3</b></a>,
        <a class="permalink" href="#avx2"><b class="Sy" id="avx2">avx2</b></a>,
        <a class="permalink" href="#avx512f"><b class="Sy" id="avx512f">avx512f</b></a>,
        <a class="permalink" href="#avx512bw"><b class="Sy" id="avx512bw">avx512bw</b></a>,
        <span class="No">and</span>
        <a class="permalink" href="#aarch64_neon"><b class="Sy" id="aarch64_neon">aarch64_neon</b></a>.
        All except <b class="Sy">fastest</b> <span class="No">and</span>
        <b class="Sy">scalar</b> require instruction set extensions to be
        available, and will only appear if ZFS detects that they are present at
        runtime. If multiple implementations of fletcher 4 are available, the
        <b class="Sy">fastest</b> will be chosen using a micro benchmark.
        Selecting <b class="Sy">scalar</b> results in the original CPU-based
        calculation being used. Selecting any option other than
        <b class="Sy">fastest</b> <span class="No">or</span>
        <b class="Sy">scalar</b> results in vector instructions from the
        respective CPU instruction set being used.</p>
  </dd>
  <dt id="zfs_free_bpobj_enabled"><a class="permalink" href="#zfs_free_bpobj_enabled"><b class="Sy">zfs_free_bpobj_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable/disable the processing of the free_bpobj object.</dd>
  <dt id="zfs_async_block_max_blocks"><a class="permalink" href="#zfs_async_block_max_blocks"><b class="Sy">zfs_async_block_max_blocks</b></a>=<b class="Sy">ULONG_MAX</b>
    (unlimited) (ulong)</dt>
  <dd>Maximum number of blocks freed in a single TXG.</dd>
  <dt id="zfs_max_async_dedup_frees"><a class="permalink" href="#zfs_max_async_dedup_frees"><b class="Sy">zfs_max_async_dedup_frees</b></a>=<a class="permalink" href="#100000"><b class="Sy" id="100000">100000</b></a>
    (10^5) (ulong)</dt>
  <dd>Maximum number of dedup blocks freed in a single TXG.</dd>
  <dt id="zfs_override_estimate_recordsize"><a class="permalink" href="#zfs_override_estimate_recordsize"><b class="Sy">zfs_override_estimate_recordsize</b></a>=<b class="Sy">0</b>
    (ulong)</dt>
  <dd>If nonzer, override record size calculation for
      <code class="Nm">zfs</code> <code class="Cm">send</code> estimates.</dd>
  <dt id="zfs_vdev_async_read_max_active"><a class="permalink" href="#zfs_vdev_async_read_max_active"><b class="Sy">zfs_vdev_async_read_max_active</b></a>=<b class="Sy">3</b>
    (int)</dt>
  <dd>Maximum asynchronous read I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_async_read_min_active"><a class="permalink" href="#zfs_vdev_async_read_min_active"><b class="Sy">zfs_vdev_async_read_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum asynchronous read I/O operation active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_async_write_active_max_dirty_percent"><a class="permalink" href="#zfs_vdev_async_write_active_max_dirty_percent"><b class="Sy">zfs_vdev_async_write_active_max_dirty_percent</b></a>=<b class="Sy">60</b>%
    (int)</dt>
  <dd>When the pool has more than this much dirty data, use
      <b class="Sy">zfs_vdev_async_write_max_active</b> to limit active async
      writes. If the dirty data is between the minimum and maximum, the active
      I/O limit is linearly interpolated. <span class="No">See</span>
      <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_async_write_active_min_dirty_percent"><a class="permalink" href="#zfs_vdev_async_write_active_min_dirty_percent"><b class="Sy">zfs_vdev_async_write_active_min_dirty_percent</b></a>=<b class="Sy">30</b>%
    (int)</dt>
  <dd>When the pool has less than this much dirty data, use
      <b class="Sy">zfs_vdev_async_write_min_active</b> to limit active async
      writes. If the dirty data is between the minimum and maximum, the active
      I/O limit is linearly interpolated. <span class="No">See</span>
      <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_async_write_max_active"><a class="permalink" href="#zfs_vdev_async_write_max_active"><b class="Sy">zfs_vdev_async_write_max_active</b></a>=<b class="Sy">30</b>
    (int)</dt>
  <dd>Maximum asynchronous write I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_async_write_min_active"><a class="permalink" href="#zfs_vdev_async_write_min_active"><b class="Sy">zfs_vdev_async_write_min_active</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Minimum asynchronous write I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.
    <p class="Pp">Lower values are associated with better latency on rotational
        media but poorer resilver performance. The default value of
        <b class="Sy">2</b> was chosen as a compromise. A value of
        <b class="Sy">3</b> has been shown to improve resilver performance
        further at a cost of further increasing latency.</p>
  </dd>
  <dt id="zfs_vdev_initializing_max_active"><a class="permalink" href="#zfs_vdev_initializing_max_active"><b class="Sy">zfs_vdev_initializing_max_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Maximum initializing I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_initializing_min_active"><a class="permalink" href="#zfs_vdev_initializing_min_active"><b class="Sy">zfs_vdev_initializing_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum initializing I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_max_active"><a class="permalink" href="#zfs_vdev_max_active"><b class="Sy">zfs_vdev_max_active</b></a>=<b class="Sy">1000</b>
    (int)</dt>
  <dd>The maximum number of I/O operations active to each device. Ideally, this
      will be at least the sum of each queue's <b class="Sy">max_active</b>.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_open_timeout_ms"><a class="permalink" href="#zfs_vdev_open_timeout_ms"><b class="Sy">zfs_vdev_open_timeout_ms</b></a>=<b class="Sy">1000</b>
    (uint)</dt>
  <dd>Timeout value to wait before determining a device is missing during
      import. This is helpful for transient missing paths due to links being
      briefly removed and recreated in response to udev events.</dd>
  <dt id="zfs_vdev_rebuild_max_active"><a class="permalink" href="#zfs_vdev_rebuild_max_active"><b class="Sy">zfs_vdev_rebuild_max_active</b></a>=<b class="Sy">3</b>
    (int)</dt>
  <dd>Maximum sequential resilver I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_rebuild_min_active"><a class="permalink" href="#zfs_vdev_rebuild_min_active"><b class="Sy">zfs_vdev_rebuild_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum sequential resilver I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_removal_max_active"><a class="permalink" href="#zfs_vdev_removal_max_active"><b class="Sy">zfs_vdev_removal_max_active</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Maximum removal I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_removal_min_active"><a class="permalink" href="#zfs_vdev_removal_min_active"><b class="Sy">zfs_vdev_removal_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum removal I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_scrub_max_active"><a class="permalink" href="#zfs_vdev_scrub_max_active"><b class="Sy">zfs_vdev_scrub_max_active</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Maximum scrub I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_scrub_min_active"><a class="permalink" href="#zfs_vdev_scrub_min_active"><b class="Sy">zfs_vdev_scrub_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum scrub I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_sync_read_max_active"><a class="permalink" href="#zfs_vdev_sync_read_max_active"><b class="Sy">zfs_vdev_sync_read_max_active</b></a>=<b class="Sy">10</b>
    (int)</dt>
  <dd>Maximum synchronous read I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_sync_read_min_active"><a class="permalink" href="#zfs_vdev_sync_read_min_active"><b class="Sy">zfs_vdev_sync_read_min_active</b></a>=<b class="Sy">10</b>
    (int)</dt>
  <dd>Minimum synchronous read I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_sync_write_max_active"><a class="permalink" href="#zfs_vdev_sync_write_max_active"><b class="Sy">zfs_vdev_sync_write_max_active</b></a>=<b class="Sy">10</b>
    (int)</dt>
  <dd>Maximum synchronous write I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_sync_write_min_active"><a class="permalink" href="#zfs_vdev_sync_write_min_active"><b class="Sy">zfs_vdev_sync_write_min_active</b></a>=<b class="Sy">10</b>
    (int)</dt>
  <dd>Minimum synchronous write I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_trim_max_active"><a class="permalink" href="#zfs_vdev_trim_max_active"><b class="Sy">zfs_vdev_trim_max_active</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Maximum trim/discard I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_trim_min_active"><a class="permalink" href="#zfs_vdev_trim_min_active"><b class="Sy">zfs_vdev_trim_min_active</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>Minimum trim/discard I/O operations active to each device.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_nia_delay"><a class="permalink" href="#zfs_vdev_nia_delay"><b class="Sy">zfs_vdev_nia_delay</b></a>=<b class="Sy">5</b>
    (int)</dt>
  <dd>For non-interactive I/O (scrub, resilver, removal, initialize and
      rebuild), the number of concurrently-active I/O operations is limited to
      <a class="permalink" href="#zfs_*_min_active"><b class="Sy" id="zfs_*_min_active">zfs_*_min_active</b></a>,
      unless the vdev is &quot;idle&quot;. When there are no interactive I/O
      operatinons active (synchronous or otherwise), and
      <b class="Sy">zfs_vdev_nia_delay</b> operations have completed since the
      last interactive operation, then the vdev is considered to be
      &quot;idle&quot;, and the number of concurrently-active non-interactive
      operations is increased to <b class="Sy">zfs_*_max_active</b>.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_nia_credit"><a class="permalink" href="#zfs_vdev_nia_credit"><b class="Sy">zfs_vdev_nia_credit</b></a>=<b class="Sy">5</b>
    (int)</dt>
  <dd>Some HDDs tend to prioritize sequential I/O so strongly, that concurrent
      random I/O latency reaches several seconds. On some HDDs this happens even
      if sequential I/O operations are submitted one at a time, and so setting
      <b class="Sy">zfs_*_max_active</b>= <b class="Sy">1</b> does not help. To
      prevent non-interactive I/O, like scrub, from monopolizing the device, no
      more than <b class="Sy">zfs_vdev_nia_credit operations can be sent</b>
      while there are outstanding incomplete interactive operations. This
      enforced wait ensures the HDD services the interactive I/O within a
      reasonable amount of time. <span class="No">See</span>
      <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_queue_depth_pct"><a class="permalink" href="#zfs_vdev_queue_depth_pct"><b class="Sy">zfs_vdev_queue_depth_pct</b></a>=<b class="Sy">1000</b>%
    (int)</dt>
  <dd>Maximum number of queued allocations per top-level vdev expressed as a
      percentage of <b class="Sy">zfs_vdev_async_write_max_active</b>, which
      allows the system to detect devices that are more capable of handling
      allocations and to allocate more blocks to those devices. This allows for
      dynamic allocation distribution when devices are imbalanced, as fuller
      devices will tend to be slower than empty devices.
    <p class="Pp">Also see <b class="Sy">zio_dva_throttle_enabled</b>.</p>
  </dd>
  <dt id="zfs_expire_snapshot"><a class="permalink" href="#zfs_expire_snapshot"><b class="Sy">zfs_expire_snapshot</b></a>=<a class="permalink" href="#300"><b class="Sy" id="300">300</b></a>s
    (int)</dt>
  <dd>Time before expiring <span class="Pa">.zfs/snapshot</span>.</dd>
  <dt id="zfs_admin_snapshot"><a class="permalink" href="#zfs_admin_snapshot"><b class="Sy">zfs_admin_snapshot</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Allow the creation, removal, or renaming of entries in the
      <a class="permalink" href="#.zfs/snapshot"><b class="Sy" id=".zfs/snapshot">.zfs/snapshot</b></a>
      directory to cause the creation, destruction, or renaming of snapshots.
      When enabled, this functionality works both locally and over NFS exports
      which have the
      <a class="permalink" href="#no_root_squash"><i class="Em" id="no_root_squash">no_root_squash</i></a>
      option set.</dd>
  <dt id="zfs_flags"><a class="permalink" href="#zfs_flags"><b class="Sy">zfs_flags</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Set additional debugging flags. The following flags may be bitwise-ored
      together:
    <table class="tbl" style="border-style: solid;">
      <tr style="border-bottom-style: solid;">
        <td><b></b></td>
        <td style="text-align: right;">Value</td>
        <td>Symbolic Name</td>
        <td>Description</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">1</td>
        <td>ZFS_DEBUG_DPRINTF</td>
        <td>Enable dprintf entries in the debug log.</td>
      </tr>
      <tr>
        <td><b>*</b></td>
        <td style="text-align: right;">2</td>
        <td>ZFS_DEBUG_DBUF_VERIFY</td>
        <td>Enable extra dbuf verifications.</td>
      </tr>
      <tr>
        <td><b>*</b></td>
        <td style="text-align: right;">4</td>
        <td>ZFS_DEBUG_DNODE_VERIFY</td>
        <td>Enable extra dnode verifications.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">8</td>
        <td>ZFS_DEBUG_SNAPNAMES</td>
        <td>Enable snapshot name verification.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">16</td>
        <td>ZFS_DEBUG_MODIFY</td>
        <td>Check for illegally modified ARC buffers.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">64</td>
        <td>ZFS_DEBUG_ZIO_FREE</td>
        <td>Enable verification of block frees.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">128</td>
        <td>ZFS_DEBUG_HISTOGRAM_VERIFY</td>
        <td>Enable extra spacemap histogram verifications.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">256</td>
        <td>ZFS_DEBUG_METASLAB_VERIFY</td>
        <td>Verify space accounting on disk matches in-memory
          <b>range_trees</b>.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">512</td>
        <td>ZFS_DEBUG_SET_ERROR</td>
        <td>Enable <b>SET_ERROR</b> and dprintf entries in the debug log.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">1024</td>
        <td>ZFS_DEBUG_INDIRECT_REMAP</td>
        <td>Verify split blocks created by device removal.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">2048</td>
        <td>ZFS_DEBUG_TRIM</td>
        <td>Verify TRIM ranges are always within the allocatable range
          tree.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">4096</td>
        <td>ZFS_DEBUG_LOG_SPACEMAP</td>
        <td>Verify that the log summary is consistent with the spacemap log</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;"></td>
        <td></td>
        <td> and enable <b>zfs_dbgmsgs</b> for metaslab loading and
          flushing.</td>
      </tr>
    </table>
    <b class="Sy"> *</b> <span class="No">Requires debug build.</span></dd>
  <dt id="zfs_btree_verify_intensity"><a class="permalink" href="#zfs_btree_verify_intensity"><b class="Sy">zfs_btree_verify_intensity</b></a>=<b class="Sy">0</b>
    (uint)</dt>
  <dd>Enables btree verification. The following settings are culminative:
    <table class="tbl" style="border-style: solid;">
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">Value</td>
        <td>Description</td>
      </tr>
      <tr>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">1</td>
        <td>Verify height.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">2</td>
        <td>Verify pointers from children to parent.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">3</td>
        <td>Verify element counts.</td>
      </tr>
      <tr>
        <td><b></b></td>
        <td style="text-align: right;">4</td>
        <td>Verify element order. (expensive)</td>
      </tr>
      <tr>
        <td><b>*</b></td>
        <td style="text-align: right;">5</td>
        <td>Verify unused memory is poisoned. (expensive)</td>
      </tr>
    </table>
    <b class="Sy"> *</b> <span class="No">Requires debug build.</span></dd>
  <dt id="zfs_free_leak_on_eio"><a class="permalink" href="#zfs_free_leak_on_eio"><b class="Sy">zfs_free_leak_on_eio</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>If destroy encounters an <b class="Sy">EIO</b> while reading metadata
      (e.g. indirect blocks), space referenced by the missing metadata can not
      be freed. Normally this causes the background destroy to become
      &quot;stalled&quot;, as it is unable to make forward progress. While in
      this stalled state, all remaining space to free from the
      error-encountering filesystem is &quot;temporarily leaked&quot;. Set this
      flag to cause it to ignore the <b class="Sy">EIO</b>, permanently leak the
      space from indirect blocks that can not be read, and continue to free
      everything else that it can.
    <p class="Pp">The default &quot;stalling&quot; behavior is useful if the
        storage partially fails (i.e. some but not all I/O operations fail), and
        then later recovers. In this case, we will be able to continue pool
        operations while it is partially failed, and when it recovers, we can
        continue to free the space, with no leaks. Note, however, that this case
        is actually fairly rare.</p>
    <p class="Pp">Typically pools either</p>
    <ol class="Bl-enum Bd-indent Bl-compact">
      <li>fail completely (but perhaps temporarily, e.g. due to a top-level vdev
          going offline), or</li>
      <li>have localized, permanent errors (e.g. disk returns the wrong data due
          to bit flip or firmware bug).</li>
    </ol>
    In the former case, this setting does not matter because the pool will be
      suspended and the sync thread will not be able to make forward progress
      regardless. In the latter, because the error is permanent, the best we can
      do is leak the minimum amount of space, which is what setting this flag
      will do. It is therefore reasonable for this flag to normally be set, but
      we chose the more conservative approach of not setting it, so that there
      is no possibility of leaking space in the &quot;partial temporary&quot;
      failure case.</dd>
  <dt id="zfs_free_min_time_ms"><a class="permalink" href="#zfs_free_min_time_ms"><b class="Sy">zfs_free_min_time_ms</b></a>=<b class="Sy">1000</b>ms
    (1s) (int)</dt>
  <dd>During a <code class="Nm">zfs</code> <code class="Cm">destroy</code>
      operation using the
      <a class="permalink" href="#async_destroy"><b class="Sy" id="async_destroy">async_destroy</b></a>
      feature, a minimum of this much time will be spent working on freeing
      blocks per TXG.</dd>
  <dt id="zfs_obsolete_min_time_ms"><a class="permalink" href="#zfs_obsolete_min_time_ms"><b class="Sy">zfs_obsolete_min_time_ms</b></a>=<b class="Sy">500</b>ms
    (int)</dt>
  <dd>Similar to <b class="Sy">zfs_free_min_time_ms</b>, but for cleanup of old
      indirection records for removed vdevs.</dd>
  <dt id="zfs_immediate_write_sz"><a class="permalink" href="#zfs_immediate_write_sz"><b class="Sy">zfs_immediate_write_sz</b></a>=<b class="Sy">32768</b>B
    (32kB) (long)</dt>
  <dd>Largest data block to write to the ZIL. Larger blocks will be treated as
      if the dataset being written to had the
      <a class="permalink" href="#logbias"><b class="Sy" id="logbias">logbias</b></a>=<a class="permalink" href="#throughput"><b class="Sy" id="throughput">throughput</b></a>
      property set.</dd>
  <dt id="zfs_initialize_value"><a class="permalink" href="#zfs_initialize_value"><b class="Sy">zfs_initialize_value</b></a>=<a class="permalink" href="#16045690984833335022"><b class="Sy" id="16045690984833335022">16045690984833335022</b></a>
    (0xDEADBEEFDEADBEEE) (ulong)</dt>
  <dd>Pattern written to vdev free space by
      <a href="../8/zpool-initialize.8.html" class="Xr">zpool-initialize(8)</a>.</dd>
  <dt id="zfs_initialize_chunk_size"><a class="permalink" href="#zfs_initialize_chunk_size"><b class="Sy">zfs_initialize_chunk_size</b></a>=<b class="Sy">1048576</b>B
    (1MB) (ulong)</dt>
  <dd>Size of writes used by <a href="../8/zpool-initialize.8.html" class="Xr">zpool-initialize(8)</a>. This option
      is used by the test suite.</dd>
  <dt id="zfs_livelist_max_entries"><a class="permalink" href="#zfs_livelist_max_entries"><b class="Sy">zfs_livelist_max_entries</b></a>=<b class="Sy">500000</b>
    (5*10^5) (ulong)</dt>
  <dd>The threshold size (in block pointers) at which we create a new
      sub-livelist. Larger sublists are more costly from a memory perspective
      but the fewer sublists there are, the lower the cost of insertion.</dd>
  <dt id="zfs_livelist_min_percent_shared"><a class="permalink" href="#zfs_livelist_min_percent_shared"><b class="Sy">zfs_livelist_min_percent_shared</b></a>=<b class="Sy">75</b>%
    (int)</dt>
  <dd>If the amount of shared space between a snapshot and its clone drops below
      this threshold, the clone turns off the livelist and reverts to the old
      deletion method. This is in place because livelists no long give us a
      benefit once a clone has been overwritten enough.</dd>
  <dt id="zfs_livelist_condense_new_alloc"><a class="permalink" href="#zfs_livelist_condense_new_alloc"><b class="Sy">zfs_livelist_condense_new_alloc</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Incremented each time an extra ALLOC blkptr is added to a livelist entry
      while it is being condensed. This option is used by the test suite to
      track race conditions.</dd>
  <dt id="zfs_livelist_condense_sync_cancel"><a class="permalink" href="#zfs_livelist_condense_sync_cancel"><b class="Sy">zfs_livelist_condense_sync_cancel</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Incremented each time livelist condensing is canceled while in
      <a class="permalink" href="#spa_livelist_condense_sync"><code class="Fn" id="spa_livelist_condense_sync">spa_livelist_condense_sync</code></a>().
      This option is used by the test suite to track race conditions.</dd>
  <dt id="zfs_livelist_condense_sync_pause"><a class="permalink" href="#zfs_livelist_condense_sync_pause"><b class="Sy">zfs_livelist_condense_sync_pause</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>When set, the livelist condense process pauses indefinitely before
      executing the synctask -
      <code class="Fn">spa_livelist_condense_sync</code>(). This option is used
      by the test suite to trigger race conditions.</dd>
  <dt id="zfs_livelist_condense_zthr_cancel"><a class="permalink" href="#zfs_livelist_condense_zthr_cancel"><b class="Sy">zfs_livelist_condense_zthr_cancel</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Incremented each time livelist condensing is canceled while in
      <a class="permalink" href="#spa_livelist_condense_cb"><code class="Fn" id="spa_livelist_condense_cb">spa_livelist_condense_cb</code></a>().
      This option is used by the test suite to track race conditions.</dd>
  <dt id="zfs_livelist_condense_zthr_pause"><a class="permalink" href="#zfs_livelist_condense_zthr_pause"><b class="Sy">zfs_livelist_condense_zthr_pause</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>When set, the livelist condense process pauses indefinitely before
      executing the open context condensing work in
      <code class="Fn">spa_livelist_condense_cb</code>(). This option is used by
      the test suite to trigger race conditions.</dd>
  <dt id="zfs_lua_max_instrlimit"><a class="permalink" href="#zfs_lua_max_instrlimit"><b class="Sy">zfs_lua_max_instrlimit</b></a>=<a class="permalink" href="#100000000"><b class="Sy" id="100000000">100000000</b></a>
    (10^8) (ulong)</dt>
  <dd>The maximum execution time limit that can be set for a ZFS channel
      program, specified as a number of Lua instructions.</dd>
  <dt id="zfs_lua_max_memlimit"><a class="permalink" href="#zfs_lua_max_memlimit"><b class="Sy">zfs_lua_max_memlimit</b></a>=<a class="permalink" href="#104857600"><b class="Sy" id="104857600">104857600</b></a>
    (100MB) (ulong)</dt>
  <dd>The maximum memory limit that can be set for a ZFS channel program,
      specified in bytes.</dd>
  <dt id="zfs_max_dataset_nesting"><a class="permalink" href="#zfs_max_dataset_nesting"><b class="Sy">zfs_max_dataset_nesting</b></a>=<a class="permalink" href="#50"><b class="Sy" id="50">50</b></a>
    (int)</dt>
  <dd>The maximum depth of nested datasets. This value can be tuned temporarily
      to fix existing datasets that exceed the predefined limit.</dd>
  <dt id="zfs_max_log_walking"><a class="permalink" href="#zfs_max_log_walking"><b class="Sy">zfs_max_log_walking</b></a>=<b class="Sy">5</b>
    (ulong)</dt>
  <dd>The number of past TXGs that the flushing algorithm of the log spacemap
      feature uses to estimate incoming log blocks.</dd>
  <dt id="zfs_max_logsm_summary_length"><a class="permalink" href="#zfs_max_logsm_summary_length"><b class="Sy">zfs_max_logsm_summary_length</b></a>=<b class="Sy">10</b>
    (ulong)</dt>
  <dd>Maximum number of rows allowed in the summary of the spacemap log.</dd>
  <dt id="zfs_max_recordsize"><a class="permalink" href="#zfs_max_recordsize"><b class="Sy">zfs_max_recordsize</b></a>=<b class="Sy">1048576</b>
    (1MB) (int)</dt>
  <dd>We currently support block sizes from
      <a class="permalink" href="#512B"><i class="Em" id="512B">512B</i></a>
      <span class="No">to</span> <i class="Em">16MB</i>. The benefits of larger
      blocks, and thus larger I/O, need to be weighed against the cost of COWing
      a giant block to modify one byte. Additionally, very large blocks can have
      an impact on I/O latency, and also potentially on the memory allocator.
      Therefore, we do not allow the recordsize to be set larger than this
      tunable. Larger blocks can be created by changing it, and pools with
      larger blocks can always be imported and used, regardless of this
    setting.</dd>
  <dt id="zfs_allow_redacted_dataset_mount"><a class="permalink" href="#zfs_allow_redacted_dataset_mount"><b class="Sy">zfs_allow_redacted_dataset_mount</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Allow datasets received with redacted send/receive to be mounted. Normally
      disabled because these datasets may be missing key data.</dd>
  <dt id="zfs_min_metaslabs_to_flush"><a class="permalink" href="#zfs_min_metaslabs_to_flush"><b class="Sy">zfs_min_metaslabs_to_flush</b></a>=<b class="Sy">1</b>
    (ulong)</dt>
  <dd>Minimum number of metaslabs to flush per dirty TXG.</dd>
  <dt id="zfs_metaslab_fragmentation_threshold"><a class="permalink" href="#zfs_metaslab_fragmentation_threshold"><b class="Sy">zfs_metaslab_fragmentation_threshold</b></a>=<a class="permalink" href="#70"><b class="Sy" id="70">70</b></a>%
    (int)</dt>
  <dd>Allow metaslabs to keep their active state as long as their fragmentation
      percentage is no more than this value. An active metaslab that exceeds
      this threshold will no longer keep its active status allowing better
      metaslabs to be selected.</dd>
  <dt id="zfs_mg_fragmentation_threshold"><a class="permalink" href="#zfs_mg_fragmentation_threshold"><b class="Sy">zfs_mg_fragmentation_threshold</b></a>=<a class="permalink" href="#95"><b class="Sy" id="95">95</b></a>%
    (int)</dt>
  <dd>Metaslab groups are considered eligible for allocations if their
      fragmentation metric (measured as a percentage) is less than or equal to
      this value. If a metaslab group exceeds this threshold then it will be
      skipped unless all metaslab groups within the metaslab class have also
      crossed this threshold.</dd>
  <dt id="zfs_mg_noalloc_threshold"><a class="permalink" href="#zfs_mg_noalloc_threshold"><b class="Sy">zfs_mg_noalloc_threshold</b></a>=<b class="Sy">0</b>%
    (int)</dt>
  <dd>Defines a threshold at which metaslab groups should be eligible for
      allocations. The value is expressed as a percentage of free space beyond
      which a metaslab group is always eligible for allocations. If a metaslab
      group's free space is less than or equal to the threshold, the allocator
      will avoid allocating to that group unless all groups in the pool have
      reached the threshold. Once all groups have reached the threshold, all
      groups are allowed to accept allocations. The default value of
      <b class="Sy">0</b> disables the feature and causes all metaslab groups to
      be eligible for allocations.
    <p class="Pp" id="zfs_mg_alloc_failures">This parameter allows one to deal
        with pools having heavily imbalanced vdevs such as would be the case
        when a new vdev has been added. Setting the threshold to a non-zero
        percentage will stop allocations from being made to vdevs that aren't
        filled to the specified percentage and allow lesser filled vdevs to
        acquire more allocations than they otherwise would under the old
        <a class="permalink" href="#zfs_mg_alloc_failures"><b class="Sy">zfs_mg_alloc_failures</b></a>
        facility.</p>
  </dd>
  <dt id="zfs_ddt_data_is_special"><a class="permalink" href="#zfs_ddt_data_is_special"><b class="Sy">zfs_ddt_data_is_special</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>If enabled, ZFS will place DDT data into the special allocation
    class.</dd>
  <dt id="zfs_user_indirect_is_special"><a class="permalink" href="#zfs_user_indirect_is_special"><b class="Sy">zfs_user_indirect_is_special</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>If enabled, ZFS will place user data indirect blocks into the special
      allocation class.</dd>
  <dt id="zfs_multihost_history"><a class="permalink" href="#zfs_multihost_history"><b class="Sy">zfs_multihost_history</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Historical statistics for this many latest multihost updates will be
      available in
      <span class="Pa">/proc/spl/kstat/zfs/</span>&#x27E8;<var class="Ar">pool</var>&#x27E9;<span class="Pa">/multihost</span>.</dd>
  <dt id="zfs_multihost_interval"><a class="permalink" href="#zfs_multihost_interval"><b class="Sy">zfs_multihost_interval</b></a>=<b class="Sy">1000</b>ms
    (1s) (ulong)</dt>
  <dd>Used to control the frequency of multihost writes which are performed when
      the
      <a class="permalink" href="#multihost"><b class="Sy" id="multihost">multihost</b></a>
      pool property is on. This is one of the factors used to determine the
      length of the activity check during import.
    <p class="Pp">The multihost write period is
        <b class="Sy">zfs_multihost_interval / leaf-vdevs</b>. On average a
        multihost write will be issued for each leaf vdev every
        <b class="Sy">zfs_multihost_interval</b> milliseconds. In practice, the
        observed period can vary with the I/O load and this observed value is
        the delay which is stored in the uberblock.</p>
  </dd>
  <dt id="zfs_multihost_import_intervals"><a class="permalink" href="#zfs_multihost_import_intervals"><b class="Sy">zfs_multihost_import_intervals</b></a>=<b class="Sy">20</b>
    (uint)</dt>
  <dd>Used to control the duration of the activity test on import. Smaller
      values of <b class="Sy">zfs_multihost_import_intervals</b> will reduce the
      import time but increase the risk of failing to detect an active pool. The
      total activity check time is never allowed to drop below one second.
    <p class="Pp" id="100ms">On import the activity check waits a minimum amount
        of time determined by <b class="Sy">zfs_multihost_interval *
        zfs_multihost_import_intervals</b>, or the same product computed on the
        host which last had the pool imported, whichever is greater. The
        activity check time may be further extended if the value of MMP delay
        found in the best uberblock indicates actual multihost updates happened
        at longer intervals than <b class="Sy">zfs_multihost_interval</b>. A
        minimum of
        <a class="permalink" href="#100ms"><i class="Em">100ms</i></a> is
        enforced.</p>
    <p class="Pp"><b class="Sy">0</b> <span class="No">is equivalent to</span>
        <b class="Sy">1</b>.</p>
  </dd>
  <dt id="zfs_multihost_fail_intervals"><a class="permalink" href="#zfs_multihost_fail_intervals"><b class="Sy">zfs_multihost_fail_intervals</b></a>=<b class="Sy">10</b>
    (uint)</dt>
  <dd>Controls the behavior of the pool when multihost write failures or delays
      are detected.
    <p class="Pp">When <b class="Sy">0</b>, multihost write failures or delays
        are ignored. The failures will still be reported to the ZED which
        depending on its configuration may take action such as suspending the
        pool or offlining a device.</p>
    <p class="Pp">Otherwise, the pool will be suspended if
        <b class="Sy">zfs_multihost_fail_intervals * zfs_multihost_interval</b>
        milliseconds pass without a successful MMP write. This guarantees the
        activity test will see MMP writes if the pool is imported.
        <b class="Sy">1</b> <span class="No">is equivalent to</span>
        <b class="Sy">2</b>; this is necessary to prevent the pool from being
        suspended due to normal, small I/O latency variations.</p>
  </dd>
  <dt id="zfs_no_scrub_io"><a class="permalink" href="#zfs_no_scrub_io"><b class="Sy">zfs_no_scrub_io</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Set to disable scrub I/O. This results in scrubs not actually scrubbing
      data and simply doing a metadata crawl of the pool instead.</dd>
  <dt id="zfs_no_scrub_prefetch"><a class="permalink" href="#zfs_no_scrub_prefetch"><b class="Sy">zfs_no_scrub_prefetch</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Set to disable block prefetching for scrubs.</dd>
  <dt id="zfs_nocacheflush"><a class="permalink" href="#zfs_nocacheflush"><b class="Sy">zfs_nocacheflush</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable cache flush operations on disks when writing. Setting this will
      cause pool corruption on power loss if a volatile out-of-order write cache
      is enabled.</dd>
  <dt id="zfs_nopwrite_enabled"><a class="permalink" href="#zfs_nopwrite_enabled"><b class="Sy">zfs_nopwrite_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Allow no-operation writes. The occurrence of nopwrites will further depend
      on other pool properties (i.a. the checksumming and compression
      algorithms).</dd>
  <dt id="zfs_dmu_offset_next_sync"><a class="permalink" href="#zfs_dmu_offset_next_sync"><b class="Sy">zfs_dmu_offset_next_sync</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Enable forcing TXG sync to find holes. When enabled forces ZFS to sync
      data when
      <a class="permalink" href="#SEEK_HOLE"><b class="Sy" id="SEEK_HOLE">SEEK_HOLE</b></a>
      <span class="No">or</span>
      <a class="permalink" href="#SEEK_DATA"><b class="Sy" id="SEEK_DATA">SEEK_DATA</b></a>
      flags are used allowing holes in a file to be accurately reported. When
      disabled holes will not be reported in recently dirtied files.</dd>
  <dt id="zfs_pd_bytes_max"><a class="permalink" href="#zfs_pd_bytes_max"><b class="Sy">zfs_pd_bytes_max</b></a>=<a class="permalink" href="#52428800"><b class="Sy" id="52428800">52428800</b></a>B
    (50MB) (int)</dt>
  <dd>The number of bytes which should be prefetched during a pool traversal,
      like <code class="Nm">zfs</code> <code class="Cm">send</code> or other
      data crawling operations.</dd>
  <dt id="zfs_traverse_indirect_prefetch_limit"><a class="permalink" href="#zfs_traverse_indirect_prefetch_limit"><b class="Sy">zfs_traverse_indirect_prefetch_limit</b></a>=<b class="Sy">32</b>
    (int)</dt>
  <dd>The number of blocks pointed by indirect (non-L0) block which should be
      prefetched during a pool traversal, like <code class="Nm">zfs</code>
      <code class="Cm">send</code> or other data crawling operations.</dd>
  <dt id="zfs_per_txg_dirty_frees_percent"><a class="permalink" href="#zfs_per_txg_dirty_frees_percent"><b class="Sy">zfs_per_txg_dirty_frees_percent</b></a>=<b class="Sy">30</b>%
    (ulong)</dt>
  <dd>Control percentage of dirtied indirect blocks from frees allowed into one
      TXG. After this threshold is crossed, additional frees will wait until the
      next TXG. <b class="Sy">0</b> <span class="No">disables this
      throttle.</span></dd>
  <dt id="zfs_prefetch_disable"><a class="permalink" href="#zfs_prefetch_disable"><b class="Sy">zfs_prefetch_disable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable predictive prefetch. Note that it leaves &quot;prescient&quot;
      prefetch (for. e.g. <code class="Nm">zfs</code>
      <code class="Cm">send</code>) intact. Unlike predictive prefetch,
      prescient prefetch never issues I/O that ends up not being needed, so it
      can't hurt performance.</dd>
  <dt id="zfs_qat_checksum_disable"><a class="permalink" href="#zfs_qat_checksum_disable"><b class="Sy">zfs_qat_checksum_disable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable QAT hardware acceleration for SHA256 checksums. May be unset after
      the ZFS modules have been loaded to initialize the QAT hardware as long as
      support is compiled in and the QAT driver is present.</dd>
  <dt id="zfs_qat_compress_disable"><a class="permalink" href="#zfs_qat_compress_disable"><b class="Sy">zfs_qat_compress_disable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable QAT hardware acceleration for gzip compression. May be unset after
      the ZFS modules have been loaded to initialize the QAT hardware as long as
      support is compiled in and the QAT driver is present.</dd>
  <dt id="zfs_qat_encrypt_disable"><a class="permalink" href="#zfs_qat_encrypt_disable"><b class="Sy">zfs_qat_encrypt_disable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable QAT hardware acceleration for AES-GCM encryption. May be unset
      after the ZFS modules have been loaded to initialize the QAT hardware as
      long as support is compiled in and the QAT driver is present.</dd>
  <dt id="zfs_vnops_read_chunk_size"><a class="permalink" href="#zfs_vnops_read_chunk_size"><b class="Sy">zfs_vnops_read_chunk_size</b></a>=<b class="Sy">1048576</b>B
    (1MB) (long)</dt>
  <dd>Bytes to read per chunk.</dd>
  <dt id="zfs_read_history"><a class="permalink" href="#zfs_read_history"><b class="Sy">zfs_read_history</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Historical statistics for this many latest reads will be available in
      <span class="Pa">/proc/spl/kstat/zfs/</span>&#x27E8;<var class="Ar">pool</var>&#x27E9;<span class="Pa">/reads</span>.</dd>
  <dt id="zfs_read_history_hits"><a class="permalink" href="#zfs_read_history_hits"><b class="Sy">zfs_read_history_hits</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Include cache hits in read history</dd>
  <dt id="zfs_rebuild_max_segment"><a class="permalink" href="#zfs_rebuild_max_segment"><b class="Sy">zfs_rebuild_max_segment</b></a>=<b class="Sy">1048576</b>B
    (1MB) (ulong)</dt>
  <dd>Maximum read segment size to issue when sequentially resilvering a
      top-level vdev.</dd>
  <dt id="zfs_rebuild_scrub_enabled"><a class="permalink" href="#zfs_rebuild_scrub_enabled"><b class="Sy">zfs_rebuild_scrub_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Automatically start a pool scrub when the last active sequential resilver
      completes in order to verify the checksums of all blocks which have been
      resilvered. This is enabled by default and strongly recommended.</dd>
  <dt id="zfs_rebuild_vdev_limit"><a class="permalink" href="#zfs_rebuild_vdev_limit"><b class="Sy">zfs_rebuild_vdev_limit</b></a>=<b class="Sy">67108864</b>B
    (64 MiB) (ulong)</dt>
  <dd>Maximum amount of I/O that can be concurrently issued for a sequential
      resilver per leaf device, given in bytes.</dd>
  <dt id="zfs_reconstruct_indirect_combinations_max"><a class="permalink" href="#zfs_reconstruct_indirect_combinations_max"><b class="Sy">zfs_reconstruct_indirect_combinations_max</b></a>=<b class="Sy">4096</b>
    (int)</dt>
  <dd>If an indirect split block contains more than this many possible unique
      combinations when being reconstructed, consider it too computationally
      expensive to check them all. Instead, try at most this many randomly
      selected combinations each time the block is accessed. This allows all
      segment copies to participate fairly in the reconstruction when all
      combinations cannot be checked and prevents repeated use of one bad
    copy.</dd>
  <dt id="zfs_recover"><a class="permalink" href="#zfs_recover"><b class="Sy">zfs_recover</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Set to attempt to recover from fatal errors. This should only be used as a
      last resort, as it typically results in leaked space, or worse.</dd>
  <dt id="zfs_removal_ignore_errors"><a class="permalink" href="#zfs_removal_ignore_errors"><b class="Sy">zfs_removal_ignore_errors</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Ignore hard IO errors during device removal. When set, if a device
      encounters a hard IO error during the removal process the removal will not
      be cancelled. This can result in a normally recoverable block becoming
      permanently damaged and is hence not recommended. This should only be used
      as a last resort when the pool cannot be returned to a healthy state prior
      to removing the device.</dd>
  <dt id="zfs_removal_suspend_progress"><a class="permalink" href="#zfs_removal_suspend_progress"><b class="Sy">zfs_removal_suspend_progress</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>This is used by the test suite so that it can ensure that certain actions
      happen while in the middle of a removal.</dd>
  <dt id="zfs_remove_max_segment"><a class="permalink" href="#zfs_remove_max_segment"><b class="Sy">zfs_remove_max_segment</b></a>=<b class="Sy">16777216</b>B
    (16MB) (int)</dt>
  <dd>The largest contiguous segment that we will attempt to allocate when
      removing a device. If there is a performance problem with attempting to
      allocate large blocks, consider decreasing this. The default value is also
      the maximum.</dd>
  <dt id="zfs_resilver_disable_defer"><a class="permalink" href="#zfs_resilver_disable_defer"><b class="Sy">zfs_resilver_disable_defer</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Ignore the
      <a class="permalink" href="#resilver_defer"><b class="Sy" id="resilver_defer">resilver_defer</b></a>
      feature, causing an operation that would start a resilver to immediately
      restart the one in progress.</dd>
  <dt id="zfs_resilver_min_time_ms"><a class="permalink" href="#zfs_resilver_min_time_ms"><b class="Sy">zfs_resilver_min_time_ms</b></a>=<a class="permalink" href="#3000"><b class="Sy" id="3000">3000</b></a>ms
    (3s) (int)</dt>
  <dd>Resilvers are processed by the sync thread. While resilvering, it will
      spend at least this much time working on a resilver between TXG
    flushes.</dd>
  <dt id="zfs_scan_ignore_errors"><a class="permalink" href="#zfs_scan_ignore_errors"><b class="Sy">zfs_scan_ignore_errors</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>If set, remove the DTL (dirty time list) upon completion of a pool scan
      (scrub), even if there were unrepairable errors. Intended to be used
      during pool repair or recovery to stop resilvering when the pool is next
      imported.</dd>
  <dt id="zfs_scrub_min_time_ms"><a class="permalink" href="#zfs_scrub_min_time_ms"><b class="Sy">zfs_scrub_min_time_ms</b></a>=<b class="Sy">1000</b>ms
    (1s) (int)</dt>
  <dd>Scrubs are processed by the sync thread. While scrubbing, it will spend at
      least this much time working on a scrub between TXG flushes.</dd>
  <dt id="zfs_scan_checkpoint_intval"><a class="permalink" href="#zfs_scan_checkpoint_intval"><b class="Sy">zfs_scan_checkpoint_intval</b></a>=<a class="permalink" href="#7200"><b class="Sy" id="7200">7200</b></a>s
    (2h) (int)</dt>
  <dd>To preserve progress across reboots, the sequential scan algorithm
      periodically needs to stop metadata scanning and issue all the
      verification I/O to disk. The frequency of this flushing is determined by
      this tunable.</dd>
  <dt id="zfs_scan_fill_weight"><a class="permalink" href="#zfs_scan_fill_weight"><b class="Sy">zfs_scan_fill_weight</b></a>=<b class="Sy">3</b>
    (int)</dt>
  <dd>This tunable affects how scrub and resilver I/O segments are ordered. A
      higher number indicates that we care more about how filled in a segment
      is, while a lower number indicates we care more about the size of the
      extent without considering the gaps within a segment. This value is only
      tunable upon module insertion. Changing the value afterwards will have no
      affect on scrub or resilver performance.</dd>
  <dt id="zfs_scan_issue_strategy"><a class="permalink" href="#zfs_scan_issue_strategy"><b class="Sy">zfs_scan_issue_strategy</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Determines the order that data will be verified while scrubbing or
      resilvering:
    <div class="Bd-indent">
    <dl class="Bl-tag Bl-compact">
      <dt id="1~2"><a class="permalink" href="#1~2"><b class="Sy">1</b></a></dt>
      <dd>Data will be verified as sequentially as possible, given the amount of
          memory reserved for scrubbing (see
          <b class="Sy">zfs_scan_mem_lim_fact</b>). This may improve scrub
          performance if the pool's data is very fragmented.</dd>
      <dt id="2"><a class="permalink" href="#2"><b class="Sy">2</b></a></dt>
      <dd>The largest mostly-contiguous chunk of found data will be verified
          first. By deferring scrubbing of small segments, we may later find
          adjacent data to coalesce and increase the segment size.</dd>
      <dt id="0~2"><a class="permalink" href="#0~2"><b class="Sy">0</b></a></dt>
      <dd><a class="permalink" href="#Use"><span class="No" id="Use">Use
          strategy</span></a> <b class="Sy">1</b> <span class="No">during normal
          verification</span> <span class="No">and strategy</span>
          <b class="Sy">2</b> <span class="No">while taking a
        checkpoint.</span></dd>
    </dl>
    </div>
  </dd>
  <dt id="zfs_scan_legacy"><a class="permalink" href="#zfs_scan_legacy"><b class="Sy">zfs_scan_legacy</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>If unset, indicates that scrubs and resilvers will gather metadata in
      memory before issuing sequential I/O. Otherwise indicates that the legacy
      algorithm will be used, where I/O is initiated as soon as it is
      discovered. Unsetting will not affect scrubs or resilvers that are already
      in progress.</dd>
  <dt id="zfs_scan_max_ext_gap"><a class="permalink" href="#zfs_scan_max_ext_gap"><b class="Sy">zfs_scan_max_ext_gap</b></a>=<a class="permalink" href="#2097152"><b class="Sy" id="2097152">2097152</b></a>B
    (2MB) (int)</dt>
  <dd>Sets the largest gap in bytes between scrub/resilver I/O operations that
      will still be considered sequential for sorting purposes. Changing this
      value will not affect scrubs or resilvers that are already in
    progress.</dd>
  <dt id="zfs_scan_mem_lim_fact"><a class="permalink" href="#zfs_scan_mem_lim_fact"><b class="Sy">zfs_scan_mem_lim_fact</b></a>=<b class="Sy">20</b>^-1
    (int)</dt>
  <dd>Maximum fraction of RAM used for I/O sorting by sequential scan algorithm.
      This tunable determines the hard limit for I/O sorting memory usage. When
      the hard limit is reached we stop scanning metadata and start issuing data
      verification I/O. This is done until we get below the soft limit.</dd>
  <dt id="zfs_scan_mem_lim_soft_fact"><a class="permalink" href="#zfs_scan_mem_lim_soft_fact"><b class="Sy">zfs_scan_mem_lim_soft_fact</b></a>=<b class="Sy">20</b>^-1
    (int)</dt>
  <dd>The fraction of the hard limit used to determined the soft limit for I/O
      sorting by the sequential scan algorithm. When we cross this limit from
      below no action is taken. When we cross this limit from above it is
      because we are issuing verification I/O. In this case (unless the metadata
      scan is done) we stop issuing verification I/O and start scanning metadata
      again until we get to the hard limit.</dd>
  <dt id="zfs_scan_report_txgs"><a class="permalink" href="#zfs_scan_report_txgs"><b class="Sy">zfs_scan_report_txgs</b></a>=<b class="Sy">0</b>|1
    (uint)</dt>
  <dd>When reporting resilver throughput and estimated completion time use the
      performance observed over roughly the last
      <b class="Sy">zfs_scan_report_txgs</b> TXGs. When set to zero performance
      is calculated over the time between checkpoints.</dd>
  <dt id="zfs_scan_strict_mem_lim"><a class="permalink" href="#zfs_scan_strict_mem_lim"><b class="Sy">zfs_scan_strict_mem_lim</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Enforce tight memory limits on pool scans when a sequential scan is in
      progress. When disabled, the memory limit may be exceeded by fast
    disks.</dd>
  <dt id="zfs_scan_suspend_progress"><a class="permalink" href="#zfs_scan_suspend_progress"><b class="Sy">zfs_scan_suspend_progress</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Freezes a scrub/resilver in progress without actually pausing it. Intended
      for testing/debugging.</dd>
  <dt id="zfs_scan_vdev_limit"><a class="permalink" href="#zfs_scan_vdev_limit"><b class="Sy">zfs_scan_vdev_limit</b></a>=<b class="Sy">16777216</b>B
    (16 MiB) (int)</dt>
  <dd>Maximum amount of data that can be concurrently issued at once for scrubs
      and resilvers per leaf device, given in bytes.</dd>
  <dt id="zfs_send_corrupt_data"><a class="permalink" href="#zfs_send_corrupt_data"><b class="Sy">zfs_send_corrupt_data</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Allow sending of corrupt data (ignore read/checksum errors when
    sending).</dd>
  <dt id="zfs_send_unmodified_spill_blocks"><a class="permalink" href="#zfs_send_unmodified_spill_blocks"><b class="Sy">zfs_send_unmodified_spill_blocks</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Include unmodified spill blocks in the send stream. Under certain
      circumstances, previous versions of ZFS could incorrectly remove the spill
      block from an existing object. Including unmodified copies of the spill
      blocks creates a backwards-compatible stream which will recreate a spill
      block if it was incorrectly removed.</dd>
  <dt id="zfs_send_no_prefetch_queue_ff"><a class="permalink" href="#zfs_send_no_prefetch_queue_ff"><b class="Sy">zfs_send_no_prefetch_queue_ff</b></a>=<b class="Sy">20</b>^-1
    (int)</dt>
  <dd>The fill fraction of the <code class="Nm">zfs</code>
      <code class="Cm">send</code> internal queues. The fill fraction controls
      the timing with which internal threads are woken up.</dd>
  <dt id="zfs_send_no_prefetch_queue_length"><a class="permalink" href="#zfs_send_no_prefetch_queue_length"><b class="Sy">zfs_send_no_prefetch_queue_length</b></a>=<b class="Sy">1048576</b>B
    (1MB) (int)</dt>
  <dd>The maximum number of bytes allowed in <code class="Nm">zfs</code>
      <code class="Cm">send</code>'s internal queues.</dd>
  <dt id="zfs_send_queue_ff"><a class="permalink" href="#zfs_send_queue_ff"><b class="Sy">zfs_send_queue_ff</b></a>=<b class="Sy">20</b>^-1
    (int)</dt>
  <dd>The fill fraction of the <code class="Nm">zfs</code>
      <code class="Cm">send</code> prefetch queue. The fill fraction controls
      the timing with which internal threads are woken up.</dd>
  <dt id="zfs_send_queue_length"><a class="permalink" href="#zfs_send_queue_length"><b class="Sy">zfs_send_queue_length</b></a>=<b class="Sy">16777216</b>B
    (16MB) (int)</dt>
  <dd>The maximum number of bytes allowed that will be prefetched by
      <code class="Nm">zfs</code> <code class="Cm">send</code>. This value must
      be at least twice the maximum block size in use.</dd>
  <dt id="zfs_recv_queue_ff"><a class="permalink" href="#zfs_recv_queue_ff"><b class="Sy">zfs_recv_queue_ff</b></a>=<b class="Sy">20</b>^-1
    (int)</dt>
  <dd>The fill fraction of the <code class="Nm">zfs</code>
      <code class="Cm">receive</code> queue. The fill fraction controls the
      timing with which internal threads are woken up.</dd>
  <dt id="zfs_recv_queue_length"><a class="permalink" href="#zfs_recv_queue_length"><b class="Sy">zfs_recv_queue_length</b></a>=<b class="Sy">16777216</b>B
    (16MB) (int)</dt>
  <dd>The maximum number of bytes allowed in the <code class="Nm">zfs</code>
      <code class="Cm">receive</code> queue. This value must be at least twice
      the maximum block size in use.</dd>
  <dt id="zfs_recv_write_batch_size"><a class="permalink" href="#zfs_recv_write_batch_size"><b class="Sy">zfs_recv_write_batch_size</b></a>=<b class="Sy">1048576</b>B
    (1MB) (int)</dt>
  <dd>The maximum amount of data, in bytes, that <code class="Nm">zfs</code>
      <code class="Cm">receive</code> will write in one DMU transaction. This is
      the uncompressed size, even when receiving a compressed send stream. This
      setting will not reduce the write size below a single block. Capped at a
      maximum of <b class="Sy">32MB</b>.</dd>
  <dt id="zfs_override_estimate_recordsize~2"><a class="permalink" href="#zfs_override_estimate_recordsize~2"><b class="Sy">zfs_override_estimate_recordsize</b></a>=<b class="Sy">0</b>|1
    (ulong)</dt>
  <dd>Setting this variable overrides the default logic for estimating block
      sizes when doing a <code class="Nm">zfs</code>
      <code class="Cm">send</code>. The default heuristic is that the average
      block size will be the current recordsize. Override this value if most
      data in your dataset is not of that size and you require accurate zfs send
      size estimates.</dd>
  <dt id="zfs_sync_pass_deferred_free"><a class="permalink" href="#zfs_sync_pass_deferred_free"><b class="Sy">zfs_sync_pass_deferred_free</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Flushing of data to disk is done in passes. Defer frees starting in this
      pass.</dd>
  <dt id="zfs_spa_discard_memory_limit"><a class="permalink" href="#zfs_spa_discard_memory_limit"><b class="Sy">zfs_spa_discard_memory_limit</b></a>=<b class="Sy">16777216</b>B
    (16MB) (int)</dt>
  <dd>Maximum memory used for prefetching a checkpoint's space map on each vdev
      while discarding the checkpoint.</dd>
  <dt id="zfs_special_class_metadata_reserve_pct"><a class="permalink" href="#zfs_special_class_metadata_reserve_pct"><b class="Sy">zfs_special_class_metadata_reserve_pct</b></a>=<b class="Sy">25</b>%
    (int)</dt>
  <dd>Only allow small data blocks to be allocated on the special and dedup vdev
      types when the available free space percentage on these vdevs exceeds this
      value. This ensures reserved space is available for pool metadata as the
      special vdevs approach capacity.</dd>
  <dt id="zfs_sync_pass_dont_compress"><a class="permalink" href="#zfs_sync_pass_dont_compress"><b class="Sy">zfs_sync_pass_dont_compress</b></a>=<b class="Sy">8</b>
    (int)</dt>
  <dd>Starting in this sync pass, disable compression (including of metadata).
      With the default setting, in practice, we don't have this many sync
      passes, so this has no effect.
    <p class="Pp">The original intent was that disabling compression would help
        the sync passes to converge. However, in practice, disabling compression
        increases the average number of sync passes; because when we turn
        compression off, many blocks' size will change, and thus we have to
        re-allocate (not overwrite) them. It also increases the number of
        <i class="Em">128kB</i> allocations (e.g. for indirect blocks and
        spacemaps) because these will not be compressed. The
        <i class="Em">128kB</i> allocations are especially detrimental to
        performance on highly fragmented systems, which may have very few free
        segments of this size, and may need to load new metaslabs to satisfy
        these allocations.</p>
  </dd>
  <dt id="zfs_sync_pass_rewrite"><a class="permalink" href="#zfs_sync_pass_rewrite"><b class="Sy">zfs_sync_pass_rewrite</b></a>=<b class="Sy">2</b>
    (int)</dt>
  <dd>Rewrite new block pointers starting in this pass.</dd>
  <dt id="zfs_sync_taskq_batch_pct"><a class="permalink" href="#zfs_sync_taskq_batch_pct"><b class="Sy">zfs_sync_taskq_batch_pct</b></a>=<b class="Sy">75</b>%
    (int)</dt>
  <dd>This controls the number of threads used by
      <a class="permalink" href="#dp_sync_taskq"><b class="Sy" id="dp_sync_taskq">dp_sync_taskq</b></a>.
      The default value of
      <a class="permalink" href="#75_"><b class="Sy" id="75_">75%</b></a> will
      create a maximum of one thread per CPU.</dd>
  <dt id="zfs_trim_extent_bytes_max"><a class="permalink" href="#zfs_trim_extent_bytes_max"><b class="Sy">zfs_trim_extent_bytes_max</b></a>=<b class="Sy">134217728</b>B
    (128MB) (uint)</dt>
  <dd>Maximum size of TRIM command. Larger ranges will be split into chunks no
      larger than this value before issuing.</dd>
  <dt id="zfs_trim_extent_bytes_min"><a class="permalink" href="#zfs_trim_extent_bytes_min"><b class="Sy">zfs_trim_extent_bytes_min</b></a>=<b class="Sy">32768</b>B
    (32kB) (uint)</dt>
  <dd>Minimum size of TRIM commands. TRIM ranges smaller than this will be
      skipped, unless they're part of a larger range which was chunked. This is
      done because it's common for these small TRIMs to negatively impact
      overall performance.</dd>
  <dt id="zfs_trim_metaslab_skip"><a class="permalink" href="#zfs_trim_metaslab_skip"><b class="Sy">zfs_trim_metaslab_skip</b></a>=<b class="Sy">0</b>|1
    (uint)</dt>
  <dd>Skip uninitialized metaslabs during the TRIM process. This option is
      useful for pools constructed from large thinly-provisioned devices where
      TRIM operations are slow. As a pool ages, an increasing fraction of the
      pool's metaslabs will be initialized, progressively degrading the
      usefulness of this option. This setting is stored when starting a manual
      TRIM and will persist for the duration of the requested TRIM.</dd>
  <dt id="zfs_trim_queue_limit"><a class="permalink" href="#zfs_trim_queue_limit"><b class="Sy">zfs_trim_queue_limit</b></a>=<b class="Sy">10</b>
    (uint)</dt>
  <dd>Maximum number of queued TRIMs outstanding per leaf vdev. The number of
      concurrent TRIM commands issued to the device is controlled by
      <b class="Sy">zfs_vdev_trim_min_active</b> <span class="No">and</span>
      <b class="Sy">zfs_vdev_trim_max_active</b>.</dd>
  <dt id="zfs_trim_txg_batch"><a class="permalink" href="#zfs_trim_txg_batch"><b class="Sy">zfs_trim_txg_batch</b></a>=<b class="Sy">32</b>
    (uint)</dt>
  <dd>The number of transaction groups' worth of frees which should be
      aggregated before TRIM operations are issued to the device. This setting
      represents a trade-off between issuing larger, more efficient TRIM
      operations and the delay before the recently trimmed space is available
      for use by the device.
    <p class="Pp">Increasing this value will allow frees to be aggregated for a
        longer time. This will result is larger TRIM operations and potentially
        increased memory usage. Decreasing this value will have the opposite
        effect. The default of <b class="Sy">32</b> was determined to be a
        reasonable compromise.</p>
  </dd>
  <dt id="zfs_txg_history"><a class="permalink" href="#zfs_txg_history"><b class="Sy">zfs_txg_history</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Historical statistics for this many latest TXGs will be available in
      <span class="Pa">/proc/spl/kstat/zfs/</span>&#x27E8;<var class="Ar">pool</var>&#x27E9;<span class="Pa">/TXGs</span>.</dd>
  <dt id="zfs_txg_timeout"><a class="permalink" href="#zfs_txg_timeout"><b class="Sy">zfs_txg_timeout</b></a>=<b class="Sy">5</b>s
    (int)</dt>
  <dd>Flush dirty data to disk at least every this many seconds (maximum TXG
      duration).</dd>
  <dt id="zfs_vdev_aggregate_trim"><a class="permalink" href="#zfs_vdev_aggregate_trim"><b class="Sy">zfs_vdev_aggregate_trim</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Allow TRIM I/Os to be aggregated. This is normally not helpful because the
      extents to be trimmed will have been already been aggregated by the
      metaslab. This option is provided for debugging and performance
    analysis.</dd>
  <dt id="zfs_vdev_aggregation_limit"><a class="permalink" href="#zfs_vdev_aggregation_limit"><b class="Sy">zfs_vdev_aggregation_limit</b></a>=<b class="Sy">1048576</b>B
    (1MB) (int)</dt>
  <dd>Max vdev I/O aggregation size.</dd>
  <dt id="zfs_vdev_aggregation_limit_non_rotating"><a class="permalink" href="#zfs_vdev_aggregation_limit_non_rotating"><b class="Sy">zfs_vdev_aggregation_limit_non_rotating</b></a>=<b class="Sy">131072</b>B
    (128kB) (int)</dt>
  <dd>Max vdev I/O aggregation size for non-rotating media.</dd>
  <dt id="zfs_vdev_cache_bshift"><a class="permalink" href="#zfs_vdev_cache_bshift"><b class="Sy">zfs_vdev_cache_bshift</b></a>=<b class="Sy">16</b>
    (64kB) (int)</dt>
  <dd>Shift size to inflate reads to.</dd>
  <dt id="zfs_vdev_cache_max"><a class="permalink" href="#zfs_vdev_cache_max"><b class="Sy">zfs_vdev_cache_max</b></a>=<b class="Sy">16384</b>B
    (16kB) (int)</dt>
  <dd>Inflate reads smaller than this value to meet the
      <b class="Sy">zfs_vdev_cache_bshift</b> size (default
      <a class="permalink" href="#64kB"><b class="Sy" id="64kB">64kB</b></a>).</dd>
  <dt id="zfs_vdev_cache_size"><a class="permalink" href="#zfs_vdev_cache_size"><b class="Sy">zfs_vdev_cache_size</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>Total size of the per-disk cache in bytes.
    <p class="Pp">Currently this feature is disabled, as it has been found to
        not be helpful for performance and in some cases harmful.</p>
  </dd>
  <dt id="zfs_vdev_mirror_rotating_inc"><a class="permalink" href="#zfs_vdev_mirror_rotating_inc"><b class="Sy">zfs_vdev_mirror_rotating_inc</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>A number by which the balancing algorithm increments the load calculation
      for the purpose of selecting the least busy mirror member when an I/O
      operation immediately follows its predecessor on rotational vdevs for the
      purpose of making decisions based on load.</dd>
  <dt id="zfs_vdev_mirror_rotating_seek_inc"><a class="permalink" href="#zfs_vdev_mirror_rotating_seek_inc"><b class="Sy">zfs_vdev_mirror_rotating_seek_inc</b></a>=<b class="Sy">5</b>
    (int)</dt>
  <dd>A number by which the balancing algorithm increments the load calculation
      for the purpose of selecting the least busy mirror member when an I/O
      operation lacks locality as defined by
      <b class="Sy">zfs_vdev_mirror_rotating_seek_offset</b>. Operations within
      this that are not immediately following the previous operation are
      incremented by half.</dd>
  <dt id="zfs_vdev_mirror_rotating_seek_offset"><a class="permalink" href="#zfs_vdev_mirror_rotating_seek_offset"><b class="Sy">zfs_vdev_mirror_rotating_seek_offset</b></a>=<b class="Sy">1048576</b>B
    (1MB) (int)</dt>
  <dd>The maximum distance for the last queued I/O operation in which the
      balancing algorithm considers an operation to have locality.
      <span class="No">See</span> <a class="Sx" href="#ZFS_I/O_SCHEDULER">ZFS
      I/O SCHEDULER</a>.</dd>
  <dt id="zfs_vdev_mirror_non_rotating_inc"><a class="permalink" href="#zfs_vdev_mirror_non_rotating_inc"><b class="Sy">zfs_vdev_mirror_non_rotating_inc</b></a>=<b class="Sy">0</b>
    (int)</dt>
  <dd>A number by which the balancing algorithm increments the load calculation
      for the purpose of selecting the least busy mirror member on
      non-rotational vdevs when I/O operations do not immediately follow one
      another.</dd>
  <dt id="zfs_vdev_mirror_non_rotating_seek_inc"><a class="permalink" href="#zfs_vdev_mirror_non_rotating_seek_inc"><b class="Sy">zfs_vdev_mirror_non_rotating_seek_inc</b></a>=<b class="Sy">1</b>
    (int)</dt>
  <dd>A number by which the balancing algorithm increments the load calculation
      for the purpose of selecting the least busy mirror member when an I/O
      operation lacks locality as defined by the
      <b class="Sy">zfs_vdev_mirror_rotating_seek_offset</b>. Operations within
      this that are not immediately following the previous operation are
      incremented by half.</dd>
  <dt id="zfs_vdev_read_gap_limit"><a class="permalink" href="#zfs_vdev_read_gap_limit"><b class="Sy">zfs_vdev_read_gap_limit</b></a>=<b class="Sy">32768</b>B
    (32kB) (int)</dt>
  <dd>Aggregate read I/O operations if the on-disk gap between them is within
      this threshold.</dd>
  <dt id="zfs_vdev_write_gap_limit"><a class="permalink" href="#zfs_vdev_write_gap_limit"><b class="Sy">zfs_vdev_write_gap_limit</b></a>=<b class="Sy">4096</b>B
    (4kB) (int)</dt>
  <dd>Aggregate write I/O operations if the on-disk gap between them is within
      this threshold.</dd>
  <dt id="zfs_vdev_raidz_impl"><a class="permalink" href="#zfs_vdev_raidz_impl"><b class="Sy">zfs_vdev_raidz_impl</b></a>=<b class="Sy">fastest</b>
    (string)</dt>
  <dd>Select the raidz parity implementation to use.
    <p class="Pp">Variants that don't depend on CPU-specific features may be
        selected on module load, as they are supported on all systems. The
        remaining options may only be set after the module is loaded, as they
        are available only if the implementations are compiled in and supported
        on the running system.</p>
    <p class="Pp">Once the module is loaded,
        <span class="Pa">/sys/module/zfs/parameters/zfs_vdev_raidz_impl</span>
        will show the available options, with the currently selected one
        enclosed in square brackets.</p>
    <p class="Pp"></p>
    <table class="tbl">
      <tr>
        <td><b>fastest</b></td>
        <td>selected by built-in benchmark</td>
      </tr>
      <tr>
        <td><b>original</b></td>
        <td>original implementation</td>
      </tr>
      <tr>
        <td><b>scalar</b></td>
        <td>scalar implementation</td>
      </tr>
      <tr>
        <td><b>sse2</b></td>
        <td>SSE2 instruction set</td>
        <td>64-bit x86</td>
      </tr>
      <tr>
        <td><b>ssse3</b></td>
        <td>SSSE3 instruction set</td>
        <td>64-bit x86</td>
      </tr>
      <tr>
        <td><b>avx2</b></td>
        <td>AVX2 instruction set</td>
        <td>64-bit x86</td>
      </tr>
      <tr>
        <td><b>avx512f</b></td>
        <td>AVX512F instruction set</td>
        <td>64-bit x86</td>
      </tr>
      <tr>
        <td><b>avx512bw</b></td>
        <td>AVX512F &amp; AVX512BW instruction sets</td>
        <td>64-bit x86</td>
      </tr>
      <tr>
        <td><b>aarch64_neon</b></td>
        <td>NEON</td>
        <td>Aarch64/64-bit ARMv8</td>
      </tr>
      <tr>
        <td><b>aarch64_neonx2</b></td>
        <td>NEON with more unrolling</td>
        <td>Aarch64/64-bit ARMv8</td>
      </tr>
      <tr>
        <td><b>powerpc_altivec</b></td>
        <td>Altivec</td>
        <td>PowerPC</td>
      </tr>
    </table>
  </dd>
  <dt id="zfs_vdev_scheduler"><a class="permalink" href="#zfs_vdev_scheduler"><b class="Sy">zfs_vdev_scheduler</b></a>
    (charp)</dt>
  <dd><a class="permalink" href="#DEPRECATED"><b class="Sy" id="DEPRECATED">DEPRECATED</b></a>.
      Prints warning to kernel log for compatibility.</dd>
  <dt id="zfs_zevent_len_max"><a class="permalink" href="#zfs_zevent_len_max"><b class="Sy">zfs_zevent_len_max</b></a>=<a class="permalink" href="#512"><b class="Sy" id="512">512</b></a>
    (int)</dt>
  <dd>Max event queue length. Events in the queue can be viewed with
      <a href="../8/zpool-events.8.html" class="Xr">zpool-events(8)</a>.</dd>
  <dt id="zfs_zevent_retain_max"><a class="permalink" href="#zfs_zevent_retain_max"><b class="Sy">zfs_zevent_retain_max</b></a>=<b class="Sy">2000</b>
    (int)</dt>
  <dd>Maximum recent zevent records to retain for duplicate checking. Setting
      this to <b class="Sy">0</b> disables duplicate detection.</dd>
  <dt id="zfs_zevent_retain_expire_secs"><a class="permalink" href="#zfs_zevent_retain_expire_secs"><b class="Sy">zfs_zevent_retain_expire_secs</b></a>=<a class="permalink" href="#900"><b class="Sy" id="900">900</b></a>s
    (15min) (int)</dt>
  <dd>Lifespan for a recent ereport that was retained for duplicate
    checking.</dd>
  <dt id="zfs_zil_clean_taskq_maxalloc"><a class="permalink" href="#zfs_zil_clean_taskq_maxalloc"><b class="Sy">zfs_zil_clean_taskq_maxalloc</b></a>=<b class="Sy">1048576</b>
    (int)</dt>
  <dd>The maximum number of taskq entries that are allowed to be cached. When
      this limit is exceeded transaction records (itxs) will be cleaned
      synchronously.</dd>
  <dt id="zfs_zil_clean_taskq_minalloc"><a class="permalink" href="#zfs_zil_clean_taskq_minalloc"><b class="Sy">zfs_zil_clean_taskq_minalloc</b></a>=<a class="permalink" href="#1024"><b class="Sy" id="1024">1024</b></a>
    (int)</dt>
  <dd>The number of taskq entries that are pre-populated when the taskq is first
      created and are immediately available for use.</dd>
  <dt id="zfs_zil_clean_taskq_nthr_pct"><a class="permalink" href="#zfs_zil_clean_taskq_nthr_pct"><b class="Sy">zfs_zil_clean_taskq_nthr_pct</b></a>=<b class="Sy">100</b>%
    (int)</dt>
  <dd>This controls the number of threads used by
      <a class="permalink" href="#dp_zil_clean_taskq"><b class="Sy" id="dp_zil_clean_taskq">dp_zil_clean_taskq</b></a>.
      The default value of
      <a class="permalink" href="#100_"><b class="Sy" id="100_">100%</b></a>
      will create a maximum of one thread per cpu.</dd>
  <dt id="zil_maxblocksize"><a class="permalink" href="#zil_maxblocksize"><b class="Sy">zil_maxblocksize</b></a>=<b class="Sy">131072</b>B
    (128kB) (int)</dt>
  <dd>This sets the maximum block size used by the ZIL. On very fragmented
      pools, lowering this (typically to
      <a class="permalink" href="#36kB"><b class="Sy" id="36kB">36kB</b></a>)
      can improve performance.</dd>
  <dt id="zil_min_commit_timeout"><a class="permalink" href="#zil_min_commit_timeout"><b class="Sy">zil_min_commit_timeout</b></a>=<a class="permalink" href="#5000"><b class="Sy" id="5000">5000</b></a>
    (u64)</dt>
  <dd>This sets the minimum delay in nanoseconds ZIL care to delay block commit,
      waiting for more records. If ZIL writes are too fast, kernel may not be
      able sleep for so short interval, increasing log latency above allowed by
      <b class="Sy">zfs_commit_timeout_pct</b>.</dd>
  <dt id="zil_nocacheflush"><a class="permalink" href="#zil_nocacheflush"><b class="Sy">zil_nocacheflush</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable the cache flush commands that are normally sent to disk by the ZIL
      after an LWB write has completed. Setting this will cause ZIL corruption
      on power loss if a volatile out-of-order write cache is enabled.</dd>
  <dt id="zil_replay_disable"><a class="permalink" href="#zil_replay_disable"><b class="Sy">zil_replay_disable</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Disable intent logging replay. Can be disabled for recovery from corrupted
      ZIL.</dd>
  <dt id="zil_slog_bulk"><a class="permalink" href="#zil_slog_bulk"><b class="Sy">zil_slog_bulk</b></a>=<a class="permalink" href="#786432"><b class="Sy" id="786432">786432</b></a>B
    (768kB) (ulong)</dt>
  <dd>Limit SLOG write size per commit executed with synchronous priority. Any
      writes above that will be executed with lower (asynchronous) priority to
      limit potential SLOG device abuse by single active ZIL writer.</dd>
  <dt id="zfs_embedded_slog_min_ms"><a class="permalink" href="#zfs_embedded_slog_min_ms"><b class="Sy">zfs_embedded_slog_min_ms</b></a>=<b class="Sy">64</b>
    (int)</dt>
  <dd>Usually, one metaslab from each normal-class vdev is dedicated for use by
      the ZIL to log synchronous writes. However, if there are fewer than
      <b class="Sy">zfs_embedded_slog_min_ms</b> metaslabs in the vdev, this
      functionality is disabled. This ensures that we don't set aside an
      unreasonable amount of space for the ZIL.</dd>
  <dt id="zio_deadman_log_all"><a class="permalink" href="#zio_deadman_log_all"><b class="Sy">zio_deadman_log_all</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>If non-zero, the zio deadman will produce debugging messages (see
      <b class="Sy">zfs_dbgmsg_enable</b>) for all zios, rather than only for
      leaf zios possessing a vdev. This is meant to be used by developers to
      gain diagnostic information for hang conditions which don't involve a
      mutex or other locking primitive: typically conditions in which a thread
      in the zio pipeline is looping indefinitely.</dd>
  <dt id="zio_slow_io_ms"><a class="permalink" href="#zio_slow_io_ms"><b class="Sy">zio_slow_io_ms</b></a>=<a class="permalink" href="#30000"><b class="Sy" id="30000">30000</b></a>ms
    (30s) (int)</dt>
  <dd>When an I/O operation takes more than this much time to complete, it's
      marked as slow. Each slow operation causes a delay zevent. Slow I/O
      counters can be seen with <code class="Nm">zpool</code>
      <code class="Cm">status</code> <code class="Fl">-s</code>.</dd>
  <dt id="zio_dva_throttle_enabled"><a class="permalink" href="#zio_dva_throttle_enabled"><b class="Sy">zio_dva_throttle_enabled</b></a>=<b class="Sy">1</b>|0
    (int)</dt>
  <dd>Throttle block allocations in the I/O pipeline. This allows for dynamic
      allocation distribution when devices are imbalanced. When enabled, the
      maximum number of pending allocations per top-level vdev is limited by
      <b class="Sy">zfs_vdev_queue_depth_pct</b>.</dd>
  <dt id="zio_requeue_io_start_cut_in_line"><a class="permalink" href="#zio_requeue_io_start_cut_in_line"><b class="Sy">zio_requeue_io_start_cut_in_line</b></a>=<b class="Sy">0</b>|1
    (int)</dt>
  <dd>Prioritize requeued I/O.</dd>
  <dt id="zio_taskq_batch_pct"><a class="permalink" href="#zio_taskq_batch_pct"><b class="Sy">zio_taskq_batch_pct</b></a>=<a class="permalink" href="#80"><b class="Sy" id="80">80</b></a>%
    (uint)</dt>
  <dd>Percentage of online CPUs which will run a worker thread for I/O. These
      workers are responsible for I/O work such as compression and checksum
      calculations. Fractional number of CPUs will be rounded down.
    <p class="Pp" id="80_">The default value of
        <a class="permalink" href="#80_"><b class="Sy">80%</b></a> was chosen to
        avoid using all CPUs which can result in latency issues and inconsistent
        application performance, especially when slower compression and/or
        checksumming is enabled.</p>
  </dd>
  <dt id="zio_taskq_batch_tpq"><a class="permalink" href="#zio_taskq_batch_tpq"><b class="Sy">zio_taskq_batch_tpq</b></a>=<b class="Sy">0</b>
    (uint)</dt>
  <dd>Number of worker threads per taskq. Lower values improve I/O ordering and
      CPU utilization, while higher reduces lock contention.
    <p class="Pp">If <b class="Sy">0</b>, generate a system-dependent value
        close to 6 threads per taskq.</p>
  </dd>
  <dt id="zio_taskq_read"><a class="permalink" href="#zio_taskq_read"><b class="Sy">zio_taskq_read</b></a>=<a class="permalink" href="#fixed,1,8"><b class="Sy" id="fixed,1,8">fixed,1,8
    null scale null</b></a> (charp)</dt>
  <dd>Set the queue and thread configuration for the IO read queues. This is an
      advanced debugging parameter. Don't change this unless you understand what
      it does.</dd>
  <dt id="zio_taskq_write"><a class="permalink" href="#zio_taskq_write"><b class="Sy">zio_taskq_write</b></a>=<a class="permalink" href="#batch"><b class="Sy" id="batch">batch
    fixed,1,5 scale fixed,1,5</b></a> (charp)</dt>
  <dd>Set the queue and thread configuration for the IO write queues. This is an
      advanced debugging parameter. Don't change this unless you understand what
      it does.</dd>
  <dt id="zvol_inhibit_dev"><a class="permalink" href="#zvol_inhibit_dev"><b class="Sy">zvol_inhibit_dev</b></a>=<b class="Sy">0</b>|1
    (uint)</dt>
  <dd>Do not create zvol device nodes. This may slightly improve startup time on
      systems with a very large number of zvols.</dd>
  <dt id="zvol_major"><a class="permalink" href="#zvol_major"><b class="Sy">zvol_major</b></a>=<a class="permalink" href="#230"><b class="Sy" id="230">230</b></a>
    (uint)</dt>
  <dd>Major number for zvol block devices.</dd>
  <dt id="zvol_max_discard_blocks"><a class="permalink" href="#zvol_max_discard_blocks"><b class="Sy">zvol_max_discard_blocks</b></a>=<b class="Sy">16384</b>
    (ulong)</dt>
  <dd>Discard (TRIM) operations done on zvols will be done in batches of this
      many blocks, where block size is determined by the
      <a class="permalink" href="#volblocksize"><b class="Sy" id="volblocksize">volblocksize</b></a>
      property of a zvol.</dd>
  <dt id="zvol_prefetch_bytes"><a class="permalink" href="#zvol_prefetch_bytes"><b class="Sy">zvol_prefetch_bytes</b></a>=<b class="Sy">131072</b>B
    (128kB) (uint)</dt>
  <dd>When adding a zvol to the system, prefetch this many bytes from the start
      and end of the volume. Prefetching these regions of the volume is
      desirable, because they are likely to be accessed immediately by
      <a class="Xr">blkid(8)</a> or the kernel partitioner.</dd>
  <dt id="zvol_request_sync"><a class="permalink" href="#zvol_request_sync"><b class="Sy">zvol_request_sync</b></a>=<b class="Sy">0</b>|1
    (uint)</dt>
  <dd>When processing I/O requests for a zvol, submit them synchronously. This
      effectively limits the queue depth to <i class="Em">1</i> for each I/O
      submitter. When unset, requests are handled asynchronously by a thread
      pool. The number of requests which can be handled concurrently is
      controlled by <b class="Sy">zvol_threads</b>.</dd>
  <dt id="zvol_threads"><a class="permalink" href="#zvol_threads"><b class="Sy">zvol_threads</b></a>=<b class="Sy">32</b>
    (uint)</dt>
  <dd>Max number of threads which can handle zvol I/O requests
    concurrently.</dd>
  <dt id="zvol_volmode"><a class="permalink" href="#zvol_volmode"><b class="Sy">zvol_volmode</b></a>=<b class="Sy">1</b>
    (uint)</dt>
  <dd>Defines zvol block devices behaviour when
      <a class="permalink" href="#volmode"><b class="Sy" id="volmode">volmode</b></a>=<a class="permalink" href="#default"><b class="Sy" id="default">default</b></a>:
    <div class="Bd-indent">
    <dl class="Bl-tag Bl-compact">
      <dt id="1~3"><a class="permalink" href="#1~3"><b class="Sy">1</b></a></dt>
      <dd><a class="permalink" href="#equivalent"><span class="No" id="equivalent">equivalent
          to</span></a>
          <a class="permalink" href="#full"><b class="Sy" id="full">full</b></a></dd>
      <dt id="2~2"><a class="permalink" href="#2~2"><b class="Sy">2</b></a></dt>
      <dd><a class="permalink" href="#equivalent~2"><span class="No" id="equivalent~2">equivalent
          to</span></a>
          <a class="permalink" href="#dev"><b class="Sy" id="dev">dev</b></a></dd>
      <dt id="3"><a class="permalink" href="#3"><b class="Sy">3</b></a></dt>
      <dd><a class="permalink" href="#equivalent~3"><span class="No" id="equivalent~3">equivalent
          to</span></a>
          <a class="permalink" href="#none"><b class="Sy" id="none">none</b></a></dd>
    </dl>
    </div>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ZFS_I/O_SCHEDULER"><a class="permalink" href="#ZFS_I/O_SCHEDULER">ZFS
  I/O SCHEDULER</a></h1>
<p class="Pp">ZFS issues I/O operations to leaf vdevs to satisfy and complete
    I/O operations. The scheduler determines when and in what order those
    operations are issued. The scheduler divides operations into five I/O
    classes, prioritized in the following order: sync read, sync write, async
    read, async write, and scrub/resilver. Each queue defines the minimum and
    maximum number of concurrent operations that may be issued to the device. In
    addition, the device has an aggregate maximum,
    <b class="Sy">zfs_vdev_max_active</b>. Note that the sum of the per-queue
    minima must not exceed the aggregate maximum. If the sum of the per-queue
    maxima exceeds the aggregate maximum, then the number of active operations
    may reach <b class="Sy">zfs_vdev_max_active</b>, in which case no further
    operations will be issued, regardless of whether all per-queue minima have
    been met.</p>
<p class="Pp">For many physical devices, throughput increases with the number of
    concurrent operations, but latency typically suffers. Furthermore, physical
    devices typically have a limit at which more concurrent operations have no
    effect on throughput or can actually cause it to decrease.</p>
<p class="Pp">The scheduler selects the next operation to issue by first looking
    for an I/O class whose minimum has not been satisfied. Once all are
    satisfied and the aggregate maximum has not been hit, the scheduler looks
    for classes whose maximum has not been satisfied. Iteration through the I/O
    classes is done in the order specified above. No further operations are
    issued if the aggregate maximum number of concurrent operations has been
    hit, or if there are no operations queued for an I/O class that has not hit
    its maximum. Every time an I/O operation is queued or an operation
    completes, the scheduler looks for new operations to issue.</p>
<p class="Pp">In general, smaller <b class="Sy">max_active</b>s will lead to
    lower latency of synchronous operations. Larger
    <b class="Sy">max_active</b>s may lead to higher overall throughput,
    depending on underlying storage.</p>
<p class="Pp">The ratio of the queues' <b class="Sy">max_active</b>s determines
    the balance of performance between reads, writes, and scrubs. For example,
    increasing <b class="Sy">zfs_vdev_scrub_max_active</b> will cause the scrub
    or resilver to complete more quickly, but reads and writes to have higher
    latency and lower throughput.</p>
<p class="Pp">All I/O classes have a fixed maximum number of outstanding
    operations, except for the async write class. Asynchronous writes represent
    the data that is committed to stable storage during the syncing stage for
    transaction groups. Transaction groups enter the syncing state periodically,
    so the number of queued async writes will quickly burst up and then bleed
    down to zero. Rather than servicing them as quickly as possible, the I/O
    scheduler changes the maximum number of active async write operations
    according to the amount of dirty data in the pool. Since both throughput and
    latency typically increase with the number of concurrent operations issued
    to physical devices, reducing the burstiness in the number of concurrent
    operations also stabilizes the response time of operations from other
    &#x2013; and in particular synchronous &#x2013; queues. In broad strokes,
    the I/O scheduler will issue more concurrent operations from the async write
    queue as there's more dirty data in the pool.</p>
<section class="Ss">
<h2 class="Ss" id="Async_Writes"><a class="permalink" href="#Async_Writes">Async
  Writes</a></h2>
<p class="Pp">The number of concurrent operations issued for the async write I/O
    class follows a piece-wise linear function defined by a few adjustable
    points:</p>
<div class="Bd Pp Li">
<pre>       |              o---------| &lt;-- <b>zfs_vdev_async_write_max_active</b>
  ^    |             /^         |
  |    |            / |         |
active |           /  |         |
 I/O   |          /   |         |
count  |         /    |         |
       |        /     |         |
       |-------o      |         | &lt;-- <b>zfs_vdev_async_write_min_active</b>
      0|_______^______|_________|
       0%      |      |       100% of <b>zfs_dirty_data_max</b>
               |      |
               |      `-- <b>zfs_vdev_async_write_active_max_dirty_percent</b>
               `--------- <b>zfs_vdev_async_write_active_min_dirty_percent</b></pre>
</div>
<p class="Pp">Until the amount of dirty data exceeds a minimum percentage of the
    dirty data allowed in the pool, the I/O scheduler will limit the number of
    concurrent operations to the minimum. As that threshold is crossed, the
    number of concurrent operations issued increases linearly to the maximum at
    the specified maximum percentage of the dirty data allowed in the pool.</p>
<p class="Pp">Ideally, the amount of dirty data on a busy pool will stay in the
    sloped part of the function between
    <b class="Sy">zfs_vdev_async_write_active_min_dirty_percent</b> and
    <b class="Sy">zfs_vdev_async_write_active_max_dirty_percent</b>. If it
    exceeds the maximum percentage, this indicates that the rate of incoming
    data is greater than the rate that the backend storage can handle. In this
    case, we must further throttle incoming writes, as described in the next
    section.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ZFS_TRANSACTION_DELAY"><a class="permalink" href="#ZFS_TRANSACTION_DELAY">ZFS
  TRANSACTION DELAY</a></h1>
<p class="Pp">We delay transactions when we've determined that the backend
    storage isn't able to accommodate the rate of incoming writes.</p>
<p class="Pp">If there is already a transaction waiting, we delay relative to
    when that transaction will finish waiting. This way the calculated delay
    time is independent of the number of threads concurrently executing
    transactions.</p>
<p class="Pp">If we are the only waiter, wait relative to when the transaction
    started, rather than the current time. This credits the transaction for
    &quot;time already served&quot;, e.g. reading indirect blocks.</p>
<p class="Pp">The minimum time for a transaction to take is calculated as</p>
<div class="Bd Bd-indent"><code class="Li">min_time =
  min(<b class="Sy">zfs_delay_scale</b> <span class="No">* (dirty - min) / (max
  - dirty), 100ms)</span></code></div>
<p class="Pp">The delay has two degrees of freedom that can be adjusted via
    tunables. The percentage of dirty data at which we start to delay is defined
    by <b class="Sy">zfs_delay_min_dirty_percent</b>. This should typically be
    at or above <b class="Sy">zfs_vdev_async_write_active_max_dirty_percent</b>,
    so that we only start to delay after writing at full speed has failed to
    keep up with the incoming write rate. The scale of the curve is defined by
    <b class="Sy">zfs_delay_scale</b>. Roughly speaking, this variable
    determines the amount of delay at the midpoint of the curve.</p>
<div class="Bd Pp Li">
<pre>delay
 10ms +-------------------------------------------------------------*+
      |                                                             *|
  9ms +                                                             *+
      |                                                             *|
  8ms +                                                             *+
      |                                                            * |
  7ms +                                                            * +
      |                                                            * |
  6ms +                                                            * +
      |                                                            * |
  5ms +                                                           *  +
      |                                                           *  |
  4ms +                                                           *  +
      |                                                           *  |
  3ms +                                                          *   +
      |                                                          *   |
  2ms +                                              (midpoint) *    +
      |                                                  |    **     |
  1ms +                                                  v ***       +
      |             <b>zfs_delay_scale</b> ----------&gt;     ********         |
    0 +-------------------------------------*********----------------+
      0%                    &lt;- <b>zfs_dirty_data_max</b> -&gt;               100%</pre>
</div>
<p class="Pp" id="500us">Note, that since the delay is added to the outstanding
    time remaining on the most recent transaction it's effectively the inverse
    of IOPS. Here, the midpoint of
    <a class="permalink" href="#500us"><i class="Em">500us</i></a> translates to
    <i class="Em">2000 IOPS</i>. The shape of the curve was chosen such that
    small changes in the amount of accumulated dirty data in the first three
    quarters of the curve yield relatively small differences in the amount of
    delay.</p>
<p class="Pp">The effects can be easier to understand when the amount of delay
    is represented on a logarithmic scale:</p>
<div class="Bd Pp Li">
<pre>delay
100ms +-------------------------------------------------------------++
      +                                                              +
      |                                                              |
      +                                                             *+
 10ms +                                                             *+
      +                                                           ** +
      |                                              (midpoint)  **  |
      +                                                  |     **    +
  1ms +                                                  v ****      +
      +             <b>zfs_delay_scale</b> ----------&gt;        *****         +
      |                                             ****             |
      +                                          ****                +
100us +                                        **                    +
      +                                       *                      +
      |                                      *                       |
      +                                     *                        +
 10us +                                     *                        +
      +                                                              +
      |                                                              |
      +                                                              +
      +--------------------------------------------------------------+
      0%                    &lt;- <b>zfs_dirty_data_max</b> -&gt;               100%</pre>
</div>
<p class="Pp">Note here that only as the amount of dirty data approaches its
    limit does the delay start to increase rapidly. The goal of a properly tuned
    system should be to keep the amount of dirty data out of that range by first
    ensuring that the appropriate limits are set for the I/O scheduler to reach
    optimal throughput on the back-end storage, and then by changing the value
    of <b class="Sy">zfs_delay_scale</b> to increase the steepness of the
  curve.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">January 10, 2023</td>
    <td class="foot-os">Debian</td>
  </tr>
</table>
</div></section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="spl.4.html" class="btn btn-neutral float-left" title="spl.4" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../5/index.html" class="btn btn-neutral float-right" title="File Formats and Conventions (5)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, OpenZFS.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>